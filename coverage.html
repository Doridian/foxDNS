
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>foxDNS: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Doridian/foxDNS/cmd/foxDNS/config.go (0.0%)</option>
				
				<option value="file1">github.com/Doridian/foxDNS/cmd/foxDNS/main.go (0.0%)</option>
				
				<option value="file2">github.com/Doridian/foxDNS/cmd/foxDNS/signals.go (0.0%)</option>
				
				<option value="file3">github.com/Doridian/foxDNS/cmd/foxDNS/signals_darwin.go (0.0%)</option>
				
				<option value="file4">github.com/Doridian/foxDNS/handler/blackhole/adlist.go (0.0%)</option>
				
				<option value="file5">github.com/Doridian/foxDNS/handler/blackhole/base.go (0.0%)</option>
				
				<option value="file6">github.com/Doridian/foxDNS/handler/dns.go (0.0%)</option>
				
				<option value="file7">github.com/Doridian/foxDNS/handler/handler.go (0.0%)</option>
				
				<option value="file8">github.com/Doridian/foxDNS/handler/localizer/base.go (72.2%)</option>
				
				<option value="file9">github.com/Doridian/foxDNS/handler/localizer/util.go (87.5%)</option>
				
				<option value="file10">github.com/Doridian/foxDNS/handler/recursive.go (0.0%)</option>
				
				<option value="file11">github.com/Doridian/foxDNS/handler/resolver/base.go (69.8%)</option>
				
				<option value="file12">github.com/Doridian/foxDNS/handler/resolver/cache.go (67.2%)</option>
				
				<option value="file13">github.com/Doridian/foxDNS/handler/resolver/exchange.go (63.2%)</option>
				
				<option value="file14">github.com/Doridian/foxDNS/handler/resolver/handler.go (57.7%)</option>
				
				<option value="file15">github.com/Doridian/foxDNS/handler/resolver/query_slots.go (48.3%)</option>
				
				<option value="file16">github.com/Doridian/foxDNS/handler/static/base.go (40.4%)</option>
				
				<option value="file17">github.com/Doridian/foxDNS/handler/static/cnames.go (9.5%)</option>
				
				<option value="file18">github.com/Doridian/foxDNS/handler/static/dnssec.go (15.6%)</option>
				
				<option value="file19">github.com/Doridian/foxDNS/handler/static/dnssec_config.go (5.6%)</option>
				
				<option value="file20">github.com/Doridian/foxDNS/handler/test_util.go (0.0%)</option>
				
				<option value="file21">github.com/Doridian/foxDNS/server/base.go (0.0%)</option>
				
				<option value="file22">github.com/Doridian/foxDNS/server/privs_darwin.go (0.0%)</option>
				
				<option value="file23">github.com/Doridian/foxDNS/util/cookie.go (0.0%)</option>
				
				<option value="file24">github.com/Doridian/foxDNS/util/depth.go (0.0%)</option>
				
				<option value="file25">github.com/Doridian/foxDNS/util/edns0.go (0.0%)</option>
				
				<option value="file26">github.com/Doridian/foxDNS/util/funcs.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "os"
        "time"

        "github.com/Doridian/foxDNS/handler/localizer"
        "github.com/Doridian/foxDNS/handler/static"
        "gopkg.in/yaml.v3"
)

type Config struct {
        // Free form field for YAML inheritance usage
        Templates interface{} `yaml:"templates"`

        Global struct {
                Listen            []string `yaml:"listen"`
                PrometheusListen  string   `yaml:"prometheus-listen"`
                UDPSize           int      `yaml:"udp-size"`
                MaxRecursionDepth int      `yaml:"max-recursion-depth"`
                RequireCookie     bool     `yaml:"require-cookie"`
        } `yaml:"global"`

        Resolvers []struct {
                Zones       []string `yaml:"zones"`
                NameServers []struct {
                        Addr               string        `yaml:"addr"`
                        Proto              string        `yaml:"proto"`
                        ServerName         string        `yaml:"server-name"`
                        RequireCookie      bool          `yaml:"require-cookie"`
                        MaxParallelQueries int           `yaml:"max-parallel-queries"`
                        Timeout            time.Duration `yaml:"timeout"`
                } `yaml:"nameservers"`
                NameServerStrategy string `yaml:"nameserver-strategy"`

                MaxIdleTime time.Duration `yaml:"max-idle-time"`
                Attempts    int           `yaml:"attempts"`
                RetryWait   time.Duration `yaml:"retry-wait"`
                LogFailures bool          `yaml:"log-failures"`

                CacheSize                 int           `yaml:"cache-size"`
                CacheMaxTime              time.Duration `yaml:"cache-max-time"`
                CacheMinTime              time.Duration `yaml:"cache-min-time"`
                CacheNoReplyTime          time.Duration `yaml:"cache-no-reply-time"`
                CacheStaleEntryKeepPeriod time.Duration `yaml:"cache-stale-entry-keep-period"`
                CacheReturnStalePeriod    time.Duration `yaml:"cache-return-stale-period"`

                OpportunisticCacheMinHits    int           `yaml:"opportunistic-cache-min-hits"`
                OpportunisticCacheMaxTimeLef time.Duration `yaml:"opportunistic-cache-max-time-left"`

                RecordMinTTL time.Duration `yaml:"record-min-ttl"`
                RecordMaxTTL time.Duration `yaml:"record-max-ttl"`
        } `yaml:"resolvers"`

        StaticZones []struct {
                Zone   string               `yaml:"zone"`
                Files  []string             `yaml:"files"`
                DNSSEC *static.DNSSECConfig `yaml:"dnssec"`

                Localizers struct {
                        Rewrites []localizer.LocalizerRewrite `yaml:"rewrites"`
                        V4V6s    []localizer.V4V6Rewrite      `yaml:"v4v6s"`
                        Hosts    []struct {
                                Host     string                       `yaml:"host"`
                                Subnets  []string                     `yaml:"subnets"`
                                Ttl      time.Duration                `yaml:"ttl"`
                                Rewrites []localizer.LocalizerRewrite `yaml:"rewrites"`
                                V4V6s    []localizer.V4V6Rewrite      `yaml:"v4v6s"`
                        } `yaml:"hosts"`
                } `yaml:"localizers"`
        } `yaml:"static-zones"`

        AdLists struct {
                AllowLists      []string      `yaml:"allow-lists"`
                BlockLists      []string      `yaml:"block-lists"`
                RefreshInterval time.Duration `yaml:"refresh-interval"`
        } `yaml:"ad-lists"`
}

func LoadConfig(file string) *Config <span class="cov0" title="0">{
        config := new(Config)

        fh, err := os.Open(file)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">dec := yaml.NewDecoder(fh)
        dec.KnownFields(true)
        err = dec.Decode(config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return config</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "net/http"
        "os"

        "github.com/Doridian/foxDNS/handler"
        "github.com/Doridian/foxDNS/handler/blackhole"
        "github.com/Doridian/foxDNS/handler/localizer"
        "github.com/Doridian/foxDNS/handler/resolver"
        "github.com/Doridian/foxDNS/handler/static"
        "github.com/Doridian/foxDNS/server"
        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var loaders = make([]handler.Loadable, 0)
var configFile string
var srv *server.Server
var enableFSNotify = os.Getenv("ENABLE_FSNOTIFY") != ""

func reloadConfig() <span class="cov0" title="0">{
        for _, gen := range loaders </span><span class="cov0" title="0">{
                err := gen.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        log.Panicf("Error stopping generator: %v", err)
                }</span>
        }

        <span class="cov0" title="0">config := LoadConfig(configFile)

        if config.Global.UDPSize &gt; 0 </span><span class="cov0" title="0">{
                util.UDPSize = uint16(config.Global.UDPSize)
        }</span>
        <span class="cov0" title="0">if config.Global.MaxRecursionDepth &gt; 0 </span><span class="cov0" title="0">{
                util.MaxRecursionDepth = config.Global.MaxRecursionDepth
        }</span>
        <span class="cov0" title="0">util.RequireCookie = config.Global.RequireCookie

        loaders = make([]handler.Loadable, 0)
        mux := dns.NewServeMux()

        for _, resolvConf := range config.Resolvers </span><span class="cov0" title="0">{
                nameServers := make([]*resolver.ServerConfig, len(resolvConf.NameServers))
                for i, ns := range resolvConf.NameServers </span><span class="cov0" title="0">{
                        nameServers[i] = &amp;resolver.ServerConfig{
                                Addr:               ns.Addr,
                                Proto:              ns.Proto,
                                ServerName:         ns.ServerName,
                                RequireCookie:      ns.RequireCookie,
                                MaxParallelQueries: ns.MaxParallelQueries,
                                Timeout:            ns.Timeout,
                        }
                }</span>

                <span class="cov0" title="0">resolv := resolver.New(nameServers)
                loaders = append(loaders, resolv)

                resolv.LogFailures = resolvConf.LogFailures

                if resolvConf.MaxIdleTime &gt; 0 </span><span class="cov0" title="0">{
                        resolv.MaxIdleTime = resolvConf.MaxIdleTime
                }</span>

                <span class="cov0" title="0">if resolvConf.Attempts &gt; 0 </span><span class="cov0" title="0">{
                        resolv.Attempts = resolvConf.Attempts
                }</span>

                <span class="cov0" title="0">if resolvConf.RetryWait &gt; 0 </span><span class="cov0" title="0">{
                        resolv.RetryWait = resolvConf.RetryWait
                }</span>

                <span class="cov0" title="0">if resolvConf.CacheSize &gt; 0 </span><span class="cov0" title="0">{
                        resolv.SetCacheSize(resolvConf.CacheSize)
                }</span>

                <span class="cov0" title="0">if resolvConf.CacheMaxTime &gt; 0 </span><span class="cov0" title="0">{
                        resolv.CacheMaxTTL = int(resolvConf.CacheMaxTime.Seconds())
                }</span>

                <span class="cov0" title="0">if resolvConf.CacheMinTime &gt; 0 </span><span class="cov0" title="0">{
                        resolv.CacheMinTTL = int(resolvConf.CacheMinTime.Seconds())
                }</span>

                <span class="cov0" title="0">if resolvConf.CacheNoReplyTime &gt; 0 </span><span class="cov0" title="0">{
                        resolv.CacheNoReplyTTL = int(resolvConf.CacheNoReplyTime.Seconds())
                }</span>

                <span class="cov0" title="0">if resolvConf.CacheStaleEntryKeepPeriod &gt; 0 </span><span class="cov0" title="0">{
                        resolv.CacheStaleEntryKeepPeriod = resolvConf.CacheStaleEntryKeepPeriod
                }</span>

                <span class="cov0" title="0">if resolvConf.CacheReturnStalePeriod &gt; 0 </span><span class="cov0" title="0">{
                        resolv.CacheReturnStalePeriod = resolvConf.CacheReturnStalePeriod
                }</span>

                <span class="cov0" title="0">if resolvConf.RecordMinTTL &gt; 0 </span><span class="cov0" title="0">{
                        resolv.RecordMinTTL = uint32(resolvConf.RecordMinTTL.Seconds())
                }</span>

                <span class="cov0" title="0">if resolvConf.RecordMaxTTL &gt; 0 </span><span class="cov0" title="0">{
                        resolv.RecordMaxTTL = uint32(resolvConf.RecordMaxTTL.Seconds())
                }</span>

                <span class="cov0" title="0">if resolvConf.OpportunisticCacheMinHits &gt; 0 </span><span class="cov0" title="0">{
                        resolv.OpportunisticCacheMinHits = uint64(resolvConf.OpportunisticCacheMinHits)
                }</span>

                <span class="cov0" title="0">if resolvConf.OpportunisticCacheMaxTimeLef &gt; 0 </span><span class="cov0" title="0">{
                        resolv.OpportunisticCacheMaxTimeLeft = resolvConf.OpportunisticCacheMaxTimeLef
                }</span>

                <span class="cov0" title="0">if resolvConf.NameServerStrategy != "" </span><span class="cov0" title="0">{
                        switch resolvConf.NameServerStrategy </span>{
                        case "round-robin":<span class="cov0" title="0">
                                resolv.ServerStrategy = resolver.StrategyRoundRobin</span>
                        case "random":<span class="cov0" title="0">
                                resolv.ServerStrategy = resolver.StrategyRandom</span>
                        case "failover":<span class="cov0" title="0">
                                resolv.ServerStrategy = resolver.StrategyFailover</span>
                        default:<span class="cov0" title="0">
                                log.Panicf("Unknown nameserver strategy: %s", resolvConf.NameServerStrategy)</span>
                        }
                }

                <span class="cov0" title="0">loaders = append(loaders, resolv)
                hdl := handler.New(resolv, false)
                for _, zone := range resolvConf.Zones </span><span class="cov0" title="0">{
                        mux.Handle(zone, hdl)
                }</span>

                <span class="cov0" title="0">log.Printf("Resolver enabled for zones %v", resolvConf.Zones)</span>
        }

        <span class="cov0" title="0">if len(config.StaticZones) &gt; 0 </span><span class="cov0" title="0">{
                for _, statConf := range config.StaticZones </span><span class="cov0" title="0">{
                        stat := static.New(enableFSNotify, mux, statConf.DNSSEC)

                        for _, file := range statConf.Files </span><span class="cov0" title="0">{
                                err := stat.LoadZoneFile(file, statConf.Zone, 3600, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Panicf("Error loading static zone file %s: %v", file, err)
                                }</span>
                        }

                        <span class="cov0" title="0">if len(statConf.Localizers.Hosts) &gt; 0 </span><span class="cov0" title="0">{
                                for _, locConfig := range statConf.Localizers.Hosts </span><span class="cov0" title="0">{
                                        loc := localizer.New()

                                        if locConfig.Ttl &gt; 0 </span><span class="cov0" title="0">{
                                                loc.Ttl = uint32(locConfig.Ttl.Seconds())
                                        }</span>

                                        <span class="cov0" title="0">rewrites := statConf.Localizers.Rewrites
                                        if locConfig.Rewrites != nil </span><span class="cov0" title="0">{
                                                rewrites = locConfig.Rewrites
                                        }</span>
                                        <span class="cov0" title="0">err := loc.AddRewrites(rewrites)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Panicf("Error adding localizer rewrites: %v", err)
                                        }</span>

                                        <span class="cov0" title="0">v4v6s := statConf.Localizers.V4V6s
                                        if locConfig.V4V6s != nil </span><span class="cov0" title="0">{
                                                v4v6s = locConfig.V4V6s
                                        }</span>
                                        <span class="cov0" title="0">err = loc.AddV4V6s(v4v6s)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Panicf("Error adding localizer v4v6s: %v", err)
                                        }</span>

                                        <span class="cov0" title="0">loaders = append(loaders, loc)

                                        for _, ip := range locConfig.Subnets </span><span class="cov0" title="0">{
                                                err := loc.AddRecord(locConfig.Host, ip)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.Panicf("Error adding localizer record %s -&gt; %s: %v", locConfig.Host, ip, err)
                                                }</span>
                                        }

                                        <span class="cov0" title="0">stat.AddSubHandler(locConfig.Host, loc)</span>
                                }

                                <span class="cov0" title="0">log.Printf("Localizer enabled for %d hosts in %s zone", len(statConf.Localizers.Hosts), statConf.Zone)</span>
                        }

                        <span class="cov0" title="0">loaders = append(loaders, stat)
                        mux.Handle(statConf.Zone, handler.New(stat, true))</span>
                }

                <span class="cov0" title="0">log.Printf("Static zones enabled for %d zones", len(config.StaticZones))</span>
        }

        <span class="cov0" title="0">if len(config.AdLists.BlockLists) &gt; 0 </span><span class="cov0" title="0">{
                adlistGen := blackhole.NewAdlist(config.AdLists.BlockLists, config.AdLists.AllowLists, mux, config.AdLists.RefreshInterval)
                loaders = append(loaders, adlistGen)
        }</span>

        <span class="cov0" title="0">srv.SetHandler(mux)

        for _, gen := range loaders </span><span class="cov0" title="0">{
                err := gen.Start()
                if err != nil </span><span class="cov0" title="0">{
                        log.Panicf("Error starting generator: %v", err)
                }</span>
        }
}

func main() <span class="cov0" title="0">{
        configFile = "config.yml"
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                configFile = os.Args[1]
        }</span>

        <span class="cov0" title="0">log.Printf("foxDNS version %s", util.Version)

        config := LoadConfig(configFile)

        if config.Global.PrometheusListen != "" </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                go func() </span><span class="cov0" title="0">{
                        err := http.ListenAndServe(config.Global.PrometheusListen, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Panicf("Error starting Prometheus listener: %v", err)
                        }</span>
                }()
        }

        <span class="cov0" title="0">srv = server.NewServer(config.Global.Listen, true)
        reloadConfig()
        handleSignals(srv)
        srv.Serve()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/Doridian/foxDNS/server"
)

func handleSignals(srv *server.Server) <span class="cov0" title="0">{
        go handleTerm(srv)
        go handleRefresh()
        go handleReload()
}</span>

func handleTerm(srv *server.Server) <span class="cov0" title="0">{
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sigs
        log.Printf("Got signal, shutting down...")
        srv.Shutdown()
}</span>

func handleReload() <span class="cov0" title="0">{
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGHUP)
        for </span><span class="cov0" title="0">{
                &lt;-sigs
                log.Printf("Got reload signal, reloading...")
                reloadConfig()
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "log"
        "os"
        "os/signal"
        "syscall"
)

func handleRefresh() <span class="cov0" title="0">{
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGUSR1)
        for </span><span class="cov0" title="0">{
                &lt;-sigs
                log.Printf("Got refreshing signal, refreshing...")
                for _, l := range loaders </span><span class="cov0" title="0">{
                        err := l.Refresh()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error refreshing loader: %v", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package blackhole

import (
        "context"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/Doridian/foxDNS/handler"
        "github.com/miekg/dns"
)

type adlistContents = map[string]bool
type adlistMap = map[string]adlistContents

type Adlist struct {
        blockLists   adlistMap
        allowLists   adlistMap
        managedHosts map[string]string
        refreshLock  sync.Mutex

        mux             *dns.ServeMux
        handlerMap      map[string]dns.Handler
        refreshInterval time.Duration
        refreshCtx      context.Context
        refreshCancel   context.CancelFunc
}

var hardcodeIgnoredAdHosts = map[string]bool{
        "localhost.":             true,
        "localhost.localdomain.": true,
        "local.":                 true,
        "localdomain.":           true,
        "broadcasthost.":         true,
        "ip6-localhost.":         true,
        "ip6-loopback.":          true,
        "ip6-localnet.":          true,
        "ip6-mcastprefix.":       true,
        "ip6-allnodes.":          true,
        "ip6-allrouters.":        true,
        "ip6-allhosts.":          true,
        ".":                      true,
}

func NewAdlist(blockLists []string, allowLists []string, mux *dns.ServeMux, refreshInterval time.Duration) *Adlist <span class="cov0" title="0">{
        blockListsMap := make(adlistMap)
        for _, list := range blockLists </span><span class="cov0" title="0">{
                blockListsMap[list] = nil
        }</span>
        <span class="cov0" title="0">allowListsMap := make(adlistMap)
        for _, list := range allowLists </span><span class="cov0" title="0">{
                allowListsMap[list] = nil
        }</span>

        <span class="cov0" title="0">return &amp;Adlist{
                blockLists:      blockListsMap,
                allowLists:      allowListsMap,
                mux:             mux,
                handlerMap:      make(map[string]dns.Handler),
                managedHosts:    make(map[string]string),
                refreshInterval: refreshInterval,
        }</span>
}

func (r *Adlist) loadList(list string) (adlistContents, error) <span class="cov0" title="0">{
        var bodyStr string

        parsedUrl, err := url.Parse(list)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var dataStream io.ReadCloser

        switch parsedUrl.Scheme </span>{
        case "file", "":<span class="cov0" title="0">
                dataStream, err = os.Open(parsedUrl.Path)</span>
        case "http", "https":<span class="cov0" title="0">
                var resp *http.Response
                resp, err = http.Get(list)
                if err == nil </span><span class="cov0" title="0">{
                        dataStream = resp.Body
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported scheme: %s", parsedUrl.Scheme)</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = dataStream.Close()
        }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(dataStream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bodyStr = string(body)

        contents := make(adlistContents)
        bodyStr = strings.ReplaceAll(bodyStr, "\r", "\n")
        for _, line := range strings.Split(bodyStr, "\n") </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">hashPos := strings.Index(line, "#")
                if hashPos == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if hashPos &gt; 0 </span><span class="cov0" title="0">{
                        line = line[:hashPos]
                }</span>
                <span class="cov0" title="0">line = strings.Trim(line, " ")
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">split := strings.Split(strings.ReplaceAll(line, "\t", " "), " ")
                for _, host := range split </span><span class="cov0" title="0">{
                        host = strings.Trim(host, ". ")
                        if host == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if net.ParseIP(host) != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">host = dns.CanonicalName(host)
                        if hardcodeIgnoredAdHosts[host] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">contents[host] = true</span>
                }
        }

        <span class="cov0" title="0">return contents, nil</span>
}

func (r *Adlist) getHandler(list string) dns.Handler <span class="cov0" title="0">{
        hdl, ok := r.handlerMap[list]
        if !ok </span><span class="cov0" title="0">{
                gen := New("adlist: " + list)
                hdl = handler.New(gen, true)
                r.handlerMap[list] = hdl
        }</span>
        <span class="cov0" title="0">return hdl</span>
}

func (r *Adlist) Refresh() error <span class="cov0" title="0">{
        r.refreshLock.Lock()
        defer r.refreshLock.Unlock()

        newManagedHosts := make(map[string]string)

        for list, contents := range r.blockLists </span><span class="cov0" title="0">{
                newContents, err := r.loadList(list)
                if err == nil </span><span class="cov0" title="0">{
                        r.blockLists[list] = newContents
                        contents = newContents
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Error loading blocklist %s: %v", list, err)
                }</span>

                <span class="cov0" title="0">for host := range contents </span><span class="cov0" title="0">{
                        if _, ok := newManagedHosts[host]; !ok </span><span class="cov0" title="0">{
                                newManagedHosts[host] = list
                        }</span> else<span class="cov0" title="0"> {
                                newManagedHosts[host] += " &amp; " + list
                        }</span>
                }
        }
        <span class="cov0" title="0">for list, contents := range r.allowLists </span><span class="cov0" title="0">{
                newContents, err := r.loadList(list)
                if err == nil </span><span class="cov0" title="0">{
                        r.allowLists[list] = newContents
                        contents = newContents
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Error loading allowlist %s: %v", list, err)
                }</span>

                <span class="cov0" title="0">for host := range contents </span><span class="cov0" title="0">{
                        delete(newManagedHosts, host)
                }</span>
        }

        <span class="cov0" title="0">usedHandlers := make(map[string]bool)
        removed := 0
        added := 0
        for host := range r.managedHosts </span><span class="cov0" title="0">{
                if _, ok := newManagedHosts[host]; !ok </span><span class="cov0" title="0">{
                        r.mux.HandleRemove(host)
                        removed++
                }</span>
        }
        <span class="cov0" title="0">for host, list := range newManagedHosts </span><span class="cov0" title="0">{
                usedHandlers[list] = true
                if _, ok := r.managedHosts[host]; !ok </span><span class="cov0" title="0">{
                        r.mux.Handle(host, r.getHandler(list))
                        added++
                }</span>
        }
        <span class="cov0" title="0">r.managedHosts = newManagedHosts

        for list := range r.handlerMap </span><span class="cov0" title="0">{
                if !usedHandlers[list] </span><span class="cov0" title="0">{
                        delete(r.handlerMap, list)
                }</span>
        }

        <span class="cov0" title="0">log.Printf(
                "Adlists refreshed, %d hosts managed with %d handlers (%d added, %d removed)",
                len(r.managedHosts),
                len(r.handlerMap),
                added,
                removed,
        )

        return nil</span>
}

func (r *Adlist) refreshLoop() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-time.After(r.refreshInterval):<span class="cov0" title="0">
                        err := r.Refresh()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error refreshing adlist: %s", err)
                        }</span>
                case &lt;-r.refreshCtx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (r *Adlist) Start() error <span class="cov0" title="0">{
        r.refreshCtx, r.refreshCancel = context.WithCancel(context.Background())
        go r.refreshLoop()
        return r.Refresh()
}</span>

func (r *Adlist) Stop() error <span class="cov0" title="0">{
        r.refreshCancel()
        return nil
}</span>

func (r *Adlist) GetName() string <span class="cov0" title="0">{
        return "adlist"
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package blackhole

import (
        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

const BlackholeHost = "blackhole.foxdns.doridian.net."

type Generator struct {
        soa   []dns.RR
        edns0 []dns.EDNS0
}

func New(reason string) *Generator <span class="cov0" title="0">{
        return &amp;Generator{
                soa: []dns.RR{
                        &amp;dns.SOA{
                                Hdr: dns.RR_Header{
                                        Name:   BlackholeHost,
                                        Rrtype: dns.TypeSOA,
                                        Class:  dns.ClassINET,
                                        Ttl:    3600,
                                },
                                Ns:      BlackholeHost,
                                Mbox:    BlackholeHost,
                                Serial:  666,
                                Refresh: 3600,
                                Retry:   3600,
                                Expire:  3600,
                                Minttl:  3600,
                        },
                },
                edns0: []dns.EDNS0{&amp;dns.EDNS0_EDE{
                        InfoCode:  dns.ExtendedErrorCodeFiltered,
                        ExtraText: reason,
                }},
        }
}</span>

func (r *Generator) HandleQuestion(_ []dns.Question, _ bool, _ bool, _ util.Addressable) ([]dns.RR, []dns.RR, []dns.EDNS0, int, string) <span class="cov0" title="0">{
        return nil, r.soa, r.edns0, dns.RcodeNameError, ""
}</span>

func (r *Generator) GetName() string <span class="cov0" title="0">{
        return "blackhole"
}</span>

func (r *Generator) Refresh() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *Generator) Start() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *Generator) Stop() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "time"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

func (h *Handler) ServeDNS(wr dns.ResponseWriter, msg *dns.Msg) <span class="cov0" title="0">{
        startTime := time.Now()

        reply := &amp;dns.Msg{
                Compress: true,
                MsgHdr: dns.MsgHdr{
                        Authoritative:      h.authoritative,
                        RecursionAvailable: util.MaxRecursionDepth &gt; 0,
                },
        }
        reply.SetRcode(msg, dns.RcodeSuccess)

        ok, edns0Options := util.ApplyEDNS0ReplyEarly(msg, reply, wr)
        if !ok </span><span class="cov0" title="0">{
                _ = wr.WriteMsg(reply)
                return
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                util.ApplyEDNS0Reply(msg, reply, edns0Options, wr)
                _ = wr.WriteMsg(reply)
        }</span>()

        <span class="cov0" title="0">if len(msg.Question) == 0 </span><span class="cov0" title="0">{
                reply.Rcode = dns.RcodeFormatError
                return
        }</span>

        <span class="cov0" title="0">queryDepth := 0
        if util.IsLocalQuery(wr) </span><span class="cov0" title="0">{
                queryDepth = len(msg.Question) - 1
        }</span> else<span class="cov0" title="0"> if len(msg.Question) &gt; 1 </span><span class="cov0" title="0">{
                reply.Rcode = dns.RcodeFormatError
                return
        }</span>

        <span class="cov0" title="0">q := &amp;msg.Question[0]
        if util.IsBadQuery(q) </span><span class="cov0" title="0">{
                reply.Rcode = dns.RcodeRefused
                return
        }</span>

        <span class="cov0" title="0">var handlerName string
        q.Name = dns.CanonicalName(q.Name)
        recurse := msg.RecursionDesired &amp;&amp; queryDepth &lt; util.MaxRecursionDepth
        dnssec := msg.IsEdns0() != nil &amp;&amp; msg.IsEdns0().Do()

        var childEdns0 []dns.EDNS0
        reply.Answer, reply.Ns, childEdns0, reply.Rcode, handlerName = h.child.HandleQuestion(msg.Question, recurse, dnssec, wr)
        if childEdns0 != nil </span><span class="cov0" title="0">{
                edns0Options = append(edns0Options, childEdns0...)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)

        rcode := dns.RcodeToString[reply.Rcode]
        if reply.Rcode == dns.RcodeSuccess &amp;&amp; len(reply.Answer) == 0 </span><span class="cov0" title="0">{
                rcode = "NXRECORD"
        }</span>

        <span class="cov0" title="0">extendedRCode := ""
        replyEdns0 := reply.IsEdns0()
        if replyEdns0 != nil </span><span class="cov0" title="0">{
                for _, opt := range replyEdns0.Option </span><span class="cov0" title="0">{
                        if opt.Option() != dns.EDNS0EDE </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">edeOpt, ok := opt.(*dns.EDNS0_EDE)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">extendedRCode = dns.ExtendedErrorCodeToString[edeOpt.InfoCode]
                        break</span>
                }
        }

        <span class="cov0" title="0">if handlerName == "" </span><span class="cov0" title="0">{
                handlerName = h.child.GetName()
        }</span>

        <span class="cov0" title="0">queriesProcessed.WithLabelValues(dns.TypeToString[q.Qtype], rcode, handlerName, extendedRCode).Inc()
        queryProcessingTime.WithLabelValues(handlerName).Observe(duration.Seconds())</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

type Handler struct {
        child         Generator
        authoritative bool
}

func New(child Generator, authoritative bool) *Handler <span class="cov0" title="0">{
        hdl := &amp;Handler{
                child:         child,
                authoritative: authoritative,
        }
        return hdl
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package localizer

import (
        "fmt"
        "net"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

type localizerRecordMap = map[string][]*localizerRecord

type LocalizerRewrite struct {
        From string `yaml:"from"`
        To   string `yaml:"to"`
}

type V4V6Rewrite struct {
        V4 string `yaml:"v4"`
        V6 string `yaml:"v6"`
}

type v4v6RewriteParsed struct {
        v4 *net.IPNet
        v6 *net.IPNet
}

type localizerRewriteParsed struct {
        fromSubnet *net.IPNet
        fromIP     net.IP
        toSubnet   *net.IPNet
        toIP       net.IP
}

type localizerRecord struct {
        subnet *net.IPNet
        ip     net.IP
}

type LocalizedRecordGenerator struct {
        aRecords   localizerRecordMap
        v4rewrites []localizerRewriteParsed

        aaaaRecords localizerRecordMap
        v6rewrites  []localizerRewriteParsed

        v4V6s []v4v6RewriteParsed

        knownHosts map[string]bool
        Ttl        uint32
}

func New() *LocalizedRecordGenerator <span class="cov8" title="1">{
        return &amp;LocalizedRecordGenerator{
                aRecords:   make(localizerRecordMap),
                v4rewrites: make([]localizerRewriteParsed, 0),

                aaaaRecords: make(localizerRecordMap),
                v6rewrites:  make([]localizerRewriteParsed, 0),

                v4V6s: make([]v4v6RewriteParsed, 0),

                knownHosts: make(map[string]bool),
                Ttl:        60,
        }
}</span>

func (r *LocalizedRecordGenerator) AddV4V6s(v4v6s []V4V6Rewrite) error <span class="cov0" title="0">{
        for _, v4v6 := range v4v6s </span><span class="cov0" title="0">{
                _, v4, err := net.ParseCIDR(v4v6.V4)
                if err != nil || v4.IP.To4() == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid v4 CIDR: %s (%v)", v4v6.V4, err)
                }</span>
                <span class="cov0" title="0">_, v6, err := net.ParseCIDR(v4v6.V6)
                if v6 == nil || v6.IP.To4() != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid v6 CIDR: %s (%v)", v4v6.V4, err)
                }</span>
                <span class="cov0" title="0">r.v4V6s = append(r.v4V6s, v4v6RewriteParsed{
                        v4: v4,
                        v6: v6,
                })</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *LocalizedRecordGenerator) AddRewrites(rewrites []LocalizerRewrite) error <span class="cov8" title="1">{
        for _, rewrite := range rewrites </span><span class="cov8" title="1">{
                fromIP, fromSubnet, err := net.ParseCIDR(rewrite.From)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fromIPv4 := fromIP.To4()
                fromIsIPv4 := fromIPv4 != nil
                if fromIsIPv4 </span><span class="cov8" title="1">{
                        fromIP = fromIPv4
                }</span>
                <span class="cov8" title="1">toIP, toSubnet, err := net.ParseCIDR(rewrite.To)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">toIPv4 := toIP.To4()
                toIsIPv4 := toIPv4 != nil
                if toIsIPv4 </span><span class="cov8" title="1">{
                        toIP = toIPv4
                }</span>

                <span class="cov8" title="1">if toIsIPv4 != fromIsIPv4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("rewrite from %s to %s has mismatched IP versions", rewrite.From, rewrite.To)
                }</span>

                <span class="cov8" title="1">parsed := localizerRewriteParsed{
                        fromSubnet: fromSubnet,
                        fromIP:     fromIP,
                        toSubnet:   toSubnet,
                        toIP:       toIP,
                }

                if fromIsIPv4 </span><span class="cov8" title="1">{
                        r.v4rewrites = append(r.v4rewrites, parsed)
                }</span> else<span class="cov8" title="1"> {
                        r.v6rewrites = append(r.v6rewrites, parsed)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *LocalizedRecordGenerator) AddRecord(hostStr string, subnetStr string) error <span class="cov8" title="1">{
        hostStr = dns.CanonicalName(hostStr)

        ip, subnet, err := net.ParseCIDR(subnetStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ipv4 := ip.To4()
        if ipv4 != nil </span><span class="cov8" title="1">{
                ip = ipv4
        }</span>

        <span class="cov8" title="1">rec := &amp;localizerRecord{
                subnet: subnet,
                ip:     ip,
        }

        var recMap localizerRecordMap
        switch len(ip) </span>{
        case net.IPv4len:<span class="cov8" title="1">
                recMap = r.aRecords</span>
        case net.IPv6len:<span class="cov8" title="1">
                recMap = r.aaaaRecords</span>
        }

        <span class="cov8" title="1">recArr := recMap[hostStr]
        if recArr == nil </span><span class="cov8" title="1">{
                recArr = make([]*localizerRecord, 0)
        }</span>
        <span class="cov8" title="1">recArr = append(recArr, rec)
        recMap[hostStr] = recArr

        r.knownHosts[hostStr] = true

        return nil</span>
}

func makeRecV4(ip net.IP) dns.RR <span class="cov8" title="1">{
        return &amp;dns.A{
                A: ip,
        }
}</span>

func makeRecV6(ip net.IP) dns.RR <span class="cov8" title="1">{
        return &amp;dns.AAAA{
                AAAA: ip,
        }
}</span>

func (r *LocalizedRecordGenerator) HandleQuestion(questions []dns.Question, _ bool, _ bool, wr util.Addressable) ([]dns.RR, []dns.RR, []dns.EDNS0, int, string) <span class="cov8" title="1">{
        q := questions[0]
        if !r.knownHosts[q.Name] </span><span class="cov0" title="0">{
                return nil, nil, nil, dns.RcodeNameError, ""
        }</span>

        <span class="cov8" title="1">var makeRecFunc func(net.IP) dns.RR
        var recsMap localizerRecordMap
        var recordIsV4 bool

        switch q.Qtype </span>{
        case dns.TypeA:<span class="cov8" title="1">
                recordIsV4 = true
                recsMap = r.aRecords
                makeRecFunc = makeRecV4</span>
        case dns.TypeAAAA:<span class="cov8" title="1">
                recordIsV4 = false
                recsMap = r.aaaaRecords
                makeRecFunc = makeRecV6</span>
        }

        <span class="cov8" title="1">if recsMap == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, dns.RcodeSuccess, ""
        }</span>

        <span class="cov8" title="1">recs := recsMap[q.Name]
        if len(recs) &lt; 1 </span><span class="cov0" title="0">{
                return nil, nil, nil, dns.RcodeSuccess, ""
        }</span>

        <span class="cov8" title="1">remoteIP := util.ExtractIP(wr.RemoteAddr())

        if remoteIP == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, dns.RcodeSuccess, ""
        }</span>

        <span class="cov8" title="1">remoteIPv4 := remoteIP.To4()
        rewrites := r.v6rewrites
        remoteIPIsV4 := remoteIPv4 != nil
        if remoteIPIsV4 </span><span class="cov8" title="1">{
                remoteIP = remoteIPv4
                rewrites = r.v4rewrites
        }</span>

        <span class="cov8" title="1">for _, rewrite := range rewrites </span><span class="cov8" title="1">{
                if rewrite.fromSubnet.Contains(remoteIP) </span><span class="cov8" title="1">{
                        remoteIP = IPNetAdd(rewrite.toSubnet, remoteIP, rewrite.toIP)
                        break</span>
                }
        }

        <span class="cov8" title="1">foundLocalIP := remoteIPIsV4 == recordIsV4
        if !foundLocalIP </span><span class="cov8" title="1">{
                remoteIPBase := remoteIP.To16()
                if recordIsV4 </span><span class="cov8" title="1">{
                        remoteIPBase = remoteIP[len(remoteIP)-net.IPv4len:]
                }</span>

                <span class="cov8" title="1">for _, v4v6Rewrite := range r.v4V6s </span><span class="cov0" title="0">{
                        remoteBase := v4v6Rewrite.v6
                        if remoteIPIsV4 </span><span class="cov0" title="0">{
                                remoteBase = v4v6Rewrite.v4
                        }</span>

                        <span class="cov0" title="0">if remoteBase.Contains(remoteIP) </span><span class="cov0" title="0">{
                                recordBase := v4v6Rewrite.v6
                                if recordIsV4 </span><span class="cov0" title="0">{
                                        recordBase = v4v6Rewrite.v4
                                }</span>

                                <span class="cov0" title="0">remoteIP = IPNetAdd(recordBase, remoteIPBase, recordBase.IP)
                                foundLocalIP = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !foundLocalIP </span><span class="cov8" title="1">{
                        return nil, nil, nil, dns.RcodeSuccess, ""
                }</span>
        }

        <span class="cov8" title="1">resp := make([]dns.RR, 0, len(recs))
        for _, rec := range recs </span><span class="cov8" title="1">{
                ipRec := IPNetAdd(rec.subnet, rec.ip, remoteIP)
                if ipRec == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">ipResRec := makeRecFunc(ipRec)
                util.FillHeader(ipResRec, q.Name, q.Qtype, r.Ttl)
                resp = append(resp, ipResRec)</span>
        }
        <span class="cov8" title="1">return resp, nil, nil, dns.RcodeSuccess, ""</span>
}

func (r *LocalizedRecordGenerator) Refresh() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *LocalizedRecordGenerator) Start() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *LocalizedRecordGenerator) Stop() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *LocalizedRecordGenerator) GetName() string <span class="cov0" title="0">{
        return "localizer"
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package localizer

import "net"

// IPNetAdd returns the result of adding the hostIP and remoteIP together, using the subnet as a mask.
// For example, assume:
// subnet = */16
// hostIP = 0.0.0.3
// remoteIP = 10.2.3.4
// This will yield the IP 10.2.0.3
func IPNetAdd(subnet *net.IPNet, hostIP net.IP, remoteIP net.IP) net.IP <span class="cov8" title="1">{
        mask := subnet.Mask
        n := len(hostIP)
        if n != len(remoteIP) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">out := make(net.IP, n)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                out[i] = (hostIP[i] &amp; ^mask[i]) | (remoteIP[i] &amp; mask[i])
        }</span>

        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "errors"
        "net"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

type RecursiveResponseWriter struct {
        wr    util.Addressable
        reply *dns.Msg
}

func NewRecursiveResponseWriter(wr util.Addressable) *RecursiveResponseWriter <span class="cov0" title="0">{
        return &amp;RecursiveResponseWriter{
                wr: wr,
        }
}</span>

func (c *RecursiveResponseWriter) Close() error <span class="cov0" title="0">{
        return errors.New("unimplemented")
}</span>

func (c *RecursiveResponseWriter) Hijack() <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

func (c *RecursiveResponseWriter) LocalAddr() net.Addr <span class="cov0" title="0">{
        return c.wr.LocalAddr()
}</span>

func (c *RecursiveResponseWriter) Network() string <span class="cov0" title="0">{
        return util.NetworkLocal
}</span>

func (c *RecursiveResponseWriter) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return c.wr.RemoteAddr()
}</span>

func (c *RecursiveResponseWriter) TsigStatus() error <span class="cov0" title="0">{
        return errors.New("unimplemented")
}</span>

func (c *RecursiveResponseWriter) TsigTimersOnly(bool) {<span class="cov0" title="0">
        // no-op
}</span>

func (c *RecursiveResponseWriter) Write([]byte) (int, error) <span class="cov0" title="0">{
        return 0, errors.New("unimplemented")
}</span>

func (c *RecursiveResponseWriter) GetMsg() *dns.Msg <span class="cov0" title="0">{
        return c.reply
}</span>

func (c *RecursiveResponseWriter) WriteMsg(reply *dns.Msg) error <span class="cov0" title="0">{
        if c.reply != nil </span><span class="cov0" title="0">{
                return errors.New("cannot write multiple messages to RecursiveResponseWriter")
        }</span>
        <span class="cov0" title="0">c.reply = reply
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package resolver

import (
        "container/list"
        "crypto/tls"
        "math"
        "sync"
        "time"

        lru "github.com/hashicorp/golang-lru/v2"
        "github.com/miekg/dns"
)

type ServerConfig struct {
        Addr               string
        Proto              string
        ServerName         string
        RequireCookie      bool
        MaxParallelQueries int
        client             *dns.Client
        Timeout            time.Duration

        freeQuerySlots  *list.List
        querySlotCond   *sync.Cond
        inFlightQueries int
}

type ServerStrategy int

const (
        StrategyRoundRobin ServerStrategy = iota
        StrategyRandom
        StrategyFailover
)

type Generator struct {
        ServerStrategy ServerStrategy
        Servers        []*ServerConfig

        lastServerIdx int
        MaxIdleTime   time.Duration
        Attempts      int
        RetryWait     time.Duration
        LogFailures   bool

        connCleanupTicker *time.Ticker
        shouldPadLen      int

        RequireCookie bool

        CacheMaxTTL               int
        CacheMinTTL               int
        CacheNoReplyTTL           int
        CacheStaleEntryKeepPeriod time.Duration
        CacheReturnStalePeriod    time.Duration

        CurrentTime func() time.Time

        RecordMinTTL uint32
        RecordMaxTTL uint32

        OpportunisticCacheMinHits     uint64
        OpportunisticCacheMaxTimeLeft time.Duration

        cache              *lru.Cache[string, *cacheEntry]
        cacheLock          *sync.Map
        cacheWriteLock     sync.Mutex
        cacheCleanupTicker *time.Ticker
}

func New(servers []*ServerConfig) *Generator <span class="cov8" title="1">{
        cache, _ := lru.New[string, *cacheEntry](4096)

        gen := &amp;Generator{
                ServerStrategy: StrategyRoundRobin,
                Servers:        servers,
                MaxIdleTime:    time.Second * 15,
                Attempts:       3,
                RetryWait:      time.Millisecond * 100,
                LogFailures:    false,

                CacheMaxTTL:               3600,
                CacheMinTTL:               0,
                CacheNoReplyTTL:           30,
                CacheStaleEntryKeepPeriod: time.Second * 15,
                CacheReturnStalePeriod:    0,

                CurrentTime: time.Now,

                RecordMinTTL: 0,
                RecordMaxTTL: math.MaxUint32,

                shouldPadLen: 0,

                OpportunisticCacheMinHits:     math.MaxUint64,
                OpportunisticCacheMaxTimeLeft: 0,

                cache:     cache,
                cacheLock: &amp;sync.Map{},
        }

        for _, srv := range gen.Servers </span><span class="cov8" title="1">{
                srv.client = &amp;dns.Client{
                        Net:          srv.Proto,
                        Timeout:      srv.Timeout,
                        DialTimeout:  srv.Timeout,
                        ReadTimeout:  srv.Timeout,
                        WriteTimeout: srv.Timeout,
                }
                srv.freeQuerySlots = list.New()
                srv.querySlotCond = sync.NewCond(&amp;sync.Mutex{})
                srv.inFlightQueries = 0
                if srv.MaxParallelQueries &lt;= 0 </span><span class="cov8" title="1">{
                        srv.MaxParallelQueries = 10
                }</span>

                <span class="cov8" title="1">if srv.Proto == "tcp-tls" </span><span class="cov0" title="0">{
                        gen.shouldPadLen = 128
                }</span>

                <span class="cov8" title="1">if srv.ServerName != "" </span><span class="cov0" title="0">{
                        srv.client.TLSConfig = &amp;tls.Config{
                                ServerName: srv.ServerName,
                        }
                }</span>
        }

        <span class="cov8" title="1">return gen</span>
}

func (g *Generator) Refresh() error <span class="cov0" title="0">{
        return nil
}</span>

func (g *Generator) Start() error <span class="cov8" title="1">{
        err := g.Stop()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cacheCleanupTicker := time.NewTicker(time.Minute)
        g.cacheCleanupTicker = cacheCleanupTicker
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        _, ok := &lt;-cacheCleanupTicker.C
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">g.cleanupCache()</span>
                }
        }()

        <span class="cov8" title="1">connCleanupTicker := time.NewTicker(g.MaxIdleTime / 2)
        g.connCleanupTicker = connCleanupTicker
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        _, ok := &lt;-connCleanupTicker.C
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">g.cleanupAllQuerySlots()</span>
                }
        }()

        <span class="cov8" title="1">return nil</span>
}

func (g *Generator) Stop() error <span class="cov8" title="1">{
        if g.cacheCleanupTicker != nil </span><span class="cov0" title="0">{
                g.cacheCleanupTicker.Stop()
                g.cacheCleanupTicker = nil
        }</span>
        <span class="cov8" title="1">if g.connCleanupTicker != nil </span><span class="cov0" title="0">{
                g.connCleanupTicker.Stop()
                g.connCleanupTicker = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (g *Generator) GetName() string <span class="cov0" title="0">{
        return "resolver"
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package resolver

import (
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/miekg/dns"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

type cacheEntry struct {
        msg *dns.Msg

        time   time.Time
        expiry time.Time
        qtype  uint16
        qclass uint16
        hits   atomic.Uint64

        refreshTriggered bool
}

var ErrNoRefreshCacheDuringRefetch = fmt.Errorf("unnecessary to refresh cache during refetch")

var (
        cacheResults = promauto.NewCounterVec(prometheus.CounterOpts{
                Name: "foxdns_resolver_cache_results",
                Help: "The number of cache hits/misses for DNS queries",
        }, []string{"result", "match_type"})

        cacheStaleHits = promauto.NewHistogram(prometheus.HistogramOpts{
                Name:    "foxdns_resolver_cache_stale_hits",
                Help:    "The number of cache hits for DNS queries that were stale",
                Buckets: []float64{1, 10, 30, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600},
        })

        cacheStaleMisses = promauto.NewHistogram(prometheus.HistogramOpts{
                Name:    "foxdns_resolver_cache_stale_misses",
                Help:    "The time since expiry of stale cache entries that were present but not usable",
                Buckets: []float64{1, 10, 30, 60, 120, 180, 240, 300, 360, 420, 480, 540, 600},
        })

        cacheSize = promauto.NewGauge(prometheus.GaugeOpts{
                Name: "foxdns_resolver_cache_size",
                Help: "The number of entries in the DNS cache",
        })

        cacheTTLHistogram = promauto.NewHistogram(prometheus.HistogramOpts{
                Name:    "foxdns_resolver_cache_ttl",
                Help:    "Upstream TTLs for DNS cache entries",
                Buckets: []float64{1, 10, 30, 60, 300, 600, 1800, 3600},
        })

        cacheHitsAtAgeOutHistogram = promauto.NewHistogram(prometheus.HistogramOpts{
                Name:    "foxdns_resolver_cache_hits_at_age_out",
                Help:    "Number of cache hits for DNS cache entries at age out",
                Buckets: []float64{0, 1, 2, 3, 4, 5, 10, 20, 50, 100},
        })
)

var (
        recursionDisabledAndNotCached = &amp;dns.Msg{
                MsgHdr: dns.MsgHdr{
                        Rcode: dns.RcodeServerFailure,
                },
                Extra: []dns.RR{
                        &amp;dns.OPT{
                                Hdr: dns.RR_Header{
                                        Rrtype: dns.TypeOPT,
                                },
                                Option: []dns.EDNS0{
                                        &amp;dns.EDNS0_EDE{
                                                InfoCode:  dns.ExtendedErrorCodeOther,
                                                ExtraText: "Recursion disabled and record not cached",
                                        },
                                },
                        },
                },
        }
)

func (g *Generator) SetCacheSize(size int) <span class="cov0" title="0">{
        g.cache.Resize(size)
}</span>

func (g *Generator) FlushCache() <span class="cov8" title="1">{
        g.cache.Purge()
}</span>

func cacheKey(q *dns.Question) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d:%d", q.Name, q.Qclass, q.Qtype)
}</span>

func cacheKeyDomain(q *dns.Question) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:ANY", q.Name)
}</span>

func (g *Generator) getOrAddCache(q *dns.Question, recurse bool, isCacheRefresh bool, incrementHits uint64) (string, string, *dns.Msg, error) <span class="cov8" title="1">{
        key := cacheKey(q)
        keyDomain := cacheKeyDomain(q)

        if !isCacheRefresh </span><span class="cov8" title="1">{
                msg, matchType := g.getFromCache(key, keyDomain, q, recurse, incrementHits)
                if msg != nil </span><span class="cov8" title="1">{
                        return "hit", matchType, msg, nil
                }</span>
        }

        <span class="cov8" title="1">if !recurse </span><span class="cov0" title="0">{
                return "", "", recursionDisabledAndNotCached, nil
        }</span>

        <span class="cov8" title="1">wg := &amp;sync.WaitGroup{}
        wg.Add(1)
        defer wg.Done()
        cacheLock, loaded := g.cacheLock.LoadOrStore(key, wg)
        cacheLockWG := cacheLock.(*sync.WaitGroup)

        if loaded </span><span class="cov0" title="0">{
                if isCacheRefresh </span><span class="cov0" title="0">{
                        return "", "", nil, ErrNoRefreshCacheDuringRefetch
                }</span>

                <span class="cov0" title="0">cacheLockWG.Wait()

                msg, matchType := g.getFromCache(key, keyDomain, q, recurse, incrementHits)
                if msg != nil </span><span class="cov0" title="0">{
                        return "wait", matchType, msg, nil
                }</span>
        } else<span class="cov8" title="1"> {
                defer g.cacheLock.Delete(key)
        }</span>

        <span class="cov8" title="1">msg, err := g.exchangeWithRetry(q)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", nil, err
        }</span>

        <span class="cov8" title="1">matchType := g.processAndWriteToCache(key, keyDomain, q, msg, incrementHits)
        return "miss", matchType, msg, nil</span>
}

func (g *Generator) cleanupCache() <span class="cov0" title="0">{
        minTime := g.CurrentTime().Add(-g.CacheStaleEntryKeepPeriod)

        toRemove := make([]string, 0)
        for _, key := range g.cache.Keys() </span><span class="cov0" title="0">{
                entry, ok := g.cache.Peek(key)
                if ok &amp;&amp; entry.expiry.Before(minTime) </span><span class="cov0" title="0">{
                        toRemove = append(toRemove, key)
                }</span>
        }

        <span class="cov0" title="0">if len(toRemove) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">g.cacheWriteLock.Lock()
        for _, key := range toRemove </span><span class="cov0" title="0">{
                entry, ok := g.cache.Peek(key)
                if ok &amp;&amp; entry.expiry.Before(minTime) </span><span class="cov0" title="0">{
                        g.cache.Remove(key)
                        cacheHitsAtAgeOutHistogram.Observe(float64(entry.hits.Load()))
                }</span>
        }
        <span class="cov0" title="0">g.cacheWriteLock.Unlock()

        cacheSize.Set(float64(g.cache.Len()))</span>
}

func (g *Generator) countdownRecordTTL(rr dns.RR, ttlAdjust uint32) <span class="cov8" title="1">{
        rrHdr := rr.Header()

        if rrHdr.Ttl &lt;= ttlAdjust </span><span class="cov0" title="0">{
                rrHdr.Ttl = 1
        }</span> else<span class="cov8" title="1"> {
                rrHdr.Ttl -= ttlAdjust
        }</span>
}

func (g *Generator) adjustRecordTTL(rr dns.RR) (*dns.RR_Header, int) <span class="cov8" title="1">{
        rrHdr := rr.Header()
        origTtl := rrHdr.Ttl

        if rrHdr.Ttl &lt; g.RecordMinTTL </span><span class="cov0" title="0">{
                rrHdr.Ttl = g.RecordMinTTL
        }</span> else<span class="cov8" title="1"> if rrHdr.Ttl &gt; g.RecordMaxTTL </span><span class="cov0" title="0">{
                rrHdr.Ttl = g.RecordMaxTTL
        }</span>

        <span class="cov8" title="1">return rrHdr, int(origTtl)</span>
}

func (g *Generator) getFromCache(key string, keyDomain string, q *dns.Question, recurse bool, incrementHits uint64) (*dns.Msg, string) <span class="cov8" title="1">{
        entry, ok := g.cache.Get(key)
        matchType := "exact"
        if !ok </span><span class="cov8" title="1">{
                entry, ok = g.cache.Get(keyDomain)
                if !ok </span><span class="cov8" title="1">{
                        return nil, ""
                }</span>
                <span class="cov0" title="0">if entry.qtype != q.Qtype || entry.qclass != q.Qclass </span><span class="cov0" title="0">{
                        matchType = "domain"
                }</span>
        }

        <span class="cov8" title="1">now := g.CurrentTime()
        entryExpiresIn := entry.expiry.Sub(now)
        if entryExpiresIn &lt;= -g.CacheReturnStalePeriod </span><span class="cov8" title="1">{
                timeSinceMiss := entryExpiresIn + g.CacheReturnStalePeriod
                cacheStaleMisses.Observe(float64(-timeSinceMiss.Seconds()))
                return nil, ""
        }</span>

        <span class="cov8" title="1">if entryExpiresIn &lt;= 0 </span><span class="cov0" title="0">{
                cacheStaleHits.Observe(float64(-entryExpiresIn.Seconds()))
        }</span>

        <span class="cov8" title="1">entryHits := entry.hits.Add(incrementHits)

        if (entryExpiresIn &lt;= 0 || (entryHits &gt;= g.OpportunisticCacheMinHits &amp;&amp; entryExpiresIn &lt;= g.OpportunisticCacheMaxTimeLeft)) &amp;&amp; !entry.refreshTriggered </span><span class="cov0" title="0">{
                entry.refreshTriggered = true
                go func() </span><span class="cov0" title="0">{
                        _, _, _, _ = g.getOrAddCache(q, recurse, true, 0)
                }</span>()
        }

        <span class="cov8" title="1">ttlAdjust := uint32(now.Sub(entry.time).Seconds())

        msg := entry.msg.Copy()

        if ttlAdjust &gt; 0 </span><span class="cov8" title="1">{
                for _, rr := range msg.Answer </span><span class="cov8" title="1">{
                        g.countdownRecordTTL(rr, ttlAdjust)
                }</span>
                <span class="cov8" title="1">for _, rr := range msg.Ns </span><span class="cov0" title="0">{
                        g.countdownRecordTTL(rr, ttlAdjust)
                }</span>
        }

        <span class="cov8" title="1">return msg, matchType</span>
}

func (g *Generator) processAndWriteToCache(key string, keyDomain string, q *dns.Question, m *dns.Msg, incrementHits uint64) string <span class="cov8" title="1">{
        minTTL := -1
        cacheTTL := -1
        authTTL := -1

        for _, rr := range m.Answer </span><span class="cov8" title="1">{
                _, ttl := g.adjustRecordTTL(rr)
                if cacheTTL &lt; 0 || ttl &lt; cacheTTL </span><span class="cov8" title="1">{
                        cacheTTL = ttl
                }</span>
        }

        <span class="cov8" title="1">for _, rr := range m.Ns </span><span class="cov8" title="1">{
                rrHdr, ttl := g.adjustRecordTTL(rr)

                if rrHdr.Rrtype == dns.TypeSOA </span><span class="cov8" title="1">{
                        minTTL = int(rr.(*dns.SOA).Minttl)
                }</span>

                <span class="cov8" title="1">if authTTL &lt; 0 || ttl &lt; authTTL </span><span class="cov8" title="1">{
                        authTTL = ttl
                }</span>
        }

        <span class="cov8" title="1">if m.Rcode != dns.RcodeSuccess &amp;&amp; m.Rcode != dns.RcodeNameError </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if cacheTTL &lt; 0 </span><span class="cov8" title="1">{
                if authTTL &gt;= 0 &amp;&amp; authTTL &lt; minTTL </span><span class="cov8" title="1">{
                        cacheTTL = authTTL
                }</span> else<span class="cov0" title="0"> if minTTL &gt;= 0 </span><span class="cov0" title="0">{
                        cacheTTL = minTTL
                }</span> else<span class="cov0" title="0"> {
                        cacheTTL = g.CacheNoReplyTTL
                }</span>
        }

        <span class="cov8" title="1">if authTTL &gt;= 0 &amp;&amp; authTTL &lt; cacheTTL </span><span class="cov0" title="0">{
                cacheTTL = authTTL
        }</span>

        <span class="cov8" title="1">cacheTTLHistogram.Observe(float64(cacheTTL))

        if cacheTTL &gt; g.CacheMaxTTL </span><span class="cov0" title="0">{
                cacheTTL = g.CacheMaxTTL
        }</span> else<span class="cov8" title="1"> if cacheTTL &lt; g.CacheMinTTL </span><span class="cov0" title="0">{
                cacheTTL = g.CacheMinTTL
        }</span>

        <span class="cov8" title="1">if cacheTTL == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">now := g.CurrentTime()
        entry := &amp;cacheEntry{
                time:   now,
                expiry: now.Add(time.Duration(cacheTTL) * time.Second),
                qtype:  q.Qtype,
                qclass: q.Qclass,
                msg:    m,
        }
        entry.hits.Store(incrementHits)

        matchType := "exact"
        if m.Rcode == dns.RcodeNameError </span><span class="cov8" title="1">{
                key = keyDomain
                matchType = "domain"
        }</span>

        <span class="cov8" title="1">g.cacheWriteLock.Lock()
        g.cache.Add(key, entry)
        g.cacheWriteLock.Unlock()

        cacheSize.Set(float64(g.cache.Len()))
        return matchType</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package resolver

import (
        "encoding/hex"
        "errors"
        "log"
        "time"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        upstreamQueryTime = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Name:    "foxdns_resolver_upstream_query_time_seconds",
                Help:    "The time it took to query an upstream resolver",
                Buckets: []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5},
        }, []string{"server"})

        upstreamQueryErrors = promauto.NewCounterVec(prometheus.CounterOpts{
                Name: "foxdns_resolver_upstream_query_errors_total",
                Help: "The total number of errors while querying upstream resolvers",
        }, []string{"server"})
)

func (g *Generator) exchange(info *querySlotInfo, m *dns.Msg) (resp *dns.Msg, err error) <span class="cov8" title="1">{
        startTime := g.CurrentTime()
        m.Id = dns.Id()
        resp, _, err = info.server.client.ExchangeWithConn(m, info.conn)

        if err == nil </span><span class="cov8" title="1">{
                duration := time.Since(startTime)
                upstreamQueryTime.WithLabelValues(info.server.Addr).Observe(duration.Seconds())
        }</span>
        <span class="cov8" title="1">return</span>
}

var ErrCookieMismatch = errors.New("client cookie returned from server invalid")

func (g *Generator) exchangeWithRetry(q *dns.Question) (resp *dns.Msg, err error) <span class="cov8" title="1">{
        var info *querySlotInfo
        keepConn := false

        for currentTry := 1; currentTry &lt;= g.Attempts; currentTry++ </span><span class="cov8" title="1">{
                if info != nil &amp;&amp; !keepConn </span><span class="cov0" title="0">{
                        g.returnQuerySlot(info, err)
                        upstreamQueryErrors.WithLabelValues(info.server.Addr).Inc()
                        info = nil
                        err = nil
                        time.Sleep(g.RetryWait)
                }</span>

                <span class="cov8" title="1">keepConn = false
                if info == nil </span><span class="cov8" title="1">{
                        info, err = g.acquireQuerySlot(currentTry)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">m := &amp;dns.Msg{
                        Compress: true,
                        Question: []dns.Question{*q},
                        MsgHdr: dns.MsgHdr{
                                Opcode:           dns.OpcodeQuery,
                                RecursionDesired: true,
                        },
                }

                // We never need the previous cookie here as we just compare generated vs returned
                clientCookie := util.GenerateClientCookie(false, info.server.Addr)
                if clientCookie == nil </span><span class="cov0" title="0">{
                        err = errors.New("failed to generate client cookie")
                        continue</span>
                }

                <span class="cov8" title="1">edns0Opts := make([]dns.EDNS0, 0, 1)
                if info.server.RequireCookie || !util.IsSecureProtocol(info.conn.RemoteAddr().Network()) </span><span class="cov8" title="1">{
                        edns0Opts = append(edns0Opts, &amp;dns.EDNS0_COOKIE{
                                Code:   dns.EDNS0COOKIE,
                                Cookie: hex.EncodeToString(append(clientCookie, info.serverCookie...)),
                        })
                }</span>
                <span class="cov8" title="1">util.SetEDNS0(m, edns0Opts, g.shouldPadLen, true)

                resp, err = g.exchange(info, m)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">cookieMatch := false
                if serverEDNS0 := resp.IsEdns0(); serverEDNS0 != nil &amp;&amp; serverEDNS0.Version() == 0 </span><span class="cov8" title="1">{
                        for _, opt := range serverEDNS0.Option </span><span class="cov8" title="1">{
                                if opt.Option() != dns.EDNS0COOKIE </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">cookieOpt, ok := opt.(*dns.EDNS0_COOKIE)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">binaryCookie, err := hex.DecodeString(cookieOpt.Cookie)
                                if err != nil || binaryCookie == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if len(binaryCookie) &lt; util.ClientCookieLength+util.MinServerCookieLength </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if util.CookieCompare(binaryCookie[:util.ClientCookieLength], clientCookie) </span><span class="cov8" title="1">{
                                        info.serverCookie = binaryCookie[util.ClientCookieLength:]
                                        cookieMatch = true
                                }</span>
                        }
                }

                <span class="cov8" title="1">if !cookieMatch &amp;&amp; info.server.RequireCookie </span><span class="cov0" title="0">{
                        err = ErrCookieMismatch
                        continue</span>
                }

                <span class="cov8" title="1">if resp.Rcode == dns.RcodeBadCookie </span><span class="cov8" title="1">{
                        keepConn = true
                        currentTry--
                        continue</span>
                }

                <span class="cov8" title="1">g.returnQuerySlot(info, nil)
                return</span>
        }

        <span class="cov0" title="0">g.returnQuerySlot(info, err)

        if g.LogFailures &amp;&amp; (err != nil || resp == nil || resp.Rcode == dns.RcodeServerFailure) </span><span class="cov0" title="0">{
                rcodeStr := ""
                if resp != nil </span><span class="cov0" title="0">{
                        rcodeStr = dns.RcodeToString[resp.Rcode]
                }</span>
                <span class="cov0" title="0">serverAddr := ""
                if info != nil &amp;&amp; info.server != nil </span><span class="cov0" title="0">{
                        serverAddr = info.server.Addr
                }</span>
                <span class="cov0" title="0">log.Printf("Failed to resolve %s[%s] @%s: %v (%s)", q.Name, dns.TypeToString[q.Qtype], serverAddr, err, rcodeStr)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package resolver

import (
        "log"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

func (g *Generator) HandleQuestion(questions []dns.Question, recurse bool, dnssec bool, _ util.Addressable) (answer []dns.RR, ns []dns.RR, edns0 []dns.EDNS0, rcode int, handlerName string) <span class="cov8" title="1">{
        rcode = dns.RcodeServerFailure

        cacheResult, matchType, upstreamReply, err := g.getOrAddCache(&amp;questions[0], recurse, false, 1)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error handling DNS request: %v", err)
                return
        }</span>

        <span class="cov8" title="1">if cacheResult != "" </span><span class="cov8" title="1">{
                cacheResults.WithLabelValues(cacheResult, matchType).Inc()
        }</span>

        <span class="cov8" title="1">rcode = upstreamReply.Rcode
        ns = upstreamReply.Ns
        answer = upstreamReply.Answer
        upstreamReplyEdns0 := upstreamReply.IsEdns0()
        if upstreamReplyEdns0 != nil </span><span class="cov8" title="1">{
                for _, upstreamOpt := range upstreamReplyEdns0.Option </span><span class="cov8" title="1">{
                        if upstreamOpt.Option() != dns.EDNS0EDE </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov0" title="0">edns0 = []dns.EDNS0{upstreamOpt}
                        break</span>
                }
        }

        <span class="cov8" title="1">if !dnssec </span><span class="cov0" title="0">{
                newAnswers := make([]dns.RR, 0, len(answer))
                for _, rr := range answer </span><span class="cov0" title="0">{
                        rrType := rr.Header().Rrtype
                        if rrType == dns.TypeRRSIG || rrType == dns.TypeNSEC || rrType == dns.TypeNSEC3 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">newAnswers = append(newAnswers, rr)</span>
                }
                <span class="cov0" title="0">answer = newAnswers</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package resolver

import (
        "log"
        "math/rand"
        "time"

        "github.com/miekg/dns"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

type querySlotInfo struct {
        conn         *dns.Conn
        server       *ServerConfig
        serverCookie []byte
        lastUse      time.Time
}

func (s *querySlotInfo) close() <span class="cov0" title="0">{
        if s.conn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">_ = s.conn.Close()</span>
}

var (
        openConnections = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Name: "foxdns_resolver_open_connections_total",
                Help: "The number of open connections to upstream resolvers",
        }, []string{"server"})
)

func (g *Generator) acquireQuerySlot(currentTry int) (info *querySlotInfo, err error) <span class="cov8" title="1">{
        var server *ServerConfig
        switch g.ServerStrategy </span>{
        case StrategyRoundRobin:<span class="cov8" title="1">
                server = g.Servers[g.lastServerIdx]
                nextServerIdx := g.lastServerIdx + 1
                if nextServerIdx &gt;= len(g.Servers) </span><span class="cov8" title="1">{
                        nextServerIdx = 0
                }</span>
                <span class="cov8" title="1">g.lastServerIdx = nextServerIdx</span>
        case StrategyRandom:<span class="cov0" title="0">
                server = g.Servers[rand.Int()%len(g.Servers)]</span>
        case StrategyFailover:<span class="cov0" title="0">
                server = g.Servers[(currentTry-1)%len(g.Servers)]</span>
        }

        <span class="cov8" title="1">server.querySlotCond.L.Lock()

        for </span><span class="cov8" title="1">{
                firstElem := server.freeQuerySlots.Front()
                if firstElem != nil </span><span class="cov8" title="1">{
                        info = server.freeQuerySlots.Remove(firstElem).(*querySlotInfo)
                        server.querySlotCond.L.Unlock()
                        return
                }</span>

                <span class="cov8" title="1">if server.inFlightQueries &lt; server.MaxParallelQueries </span><span class="cov8" title="1">{
                        server.inFlightQueries++
                        openConnections.WithLabelValues(server.Addr).Set(float64(server.inFlightQueries))

                        server.querySlotCond.L.Unlock()
                        info = &amp;querySlotInfo{
                                server:       server,
                                serverCookie: []byte{},
                        }
                        info.conn, err = server.client.Dial(server.Addr)
                        return
                }</span>

                <span class="cov0" title="0">server.querySlotCond.Wait()</span>
        }
}

func (g *Generator) returnQuerySlot(info *querySlotInfo, err error) <span class="cov8" title="1">{
        if info == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">server := info.server

        server.querySlotCond.L.Lock()
        defer server.querySlotCond.L.Unlock()

        if err == nil </span><span class="cov8" title="1">{
                info.lastUse = g.CurrentTime()
                server.freeQuerySlots.PushFront(info)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Returning upstream connection to %s with error %v", info.server.Addr, err)
                server.inFlightQueries--
                openConnections.WithLabelValues(server.Addr).Set(float64(server.inFlightQueries))
                if info.conn != nil </span><span class="cov0" title="0">{
                        go info.close()
                }</span>
        }

        <span class="cov8" title="1">server.querySlotCond.Signal()</span>
}

func (g *Generator) cleanupServerQuerySlots(server *ServerConfig) <span class="cov0" title="0">{
        server.querySlotCond.L.Lock()
        defer server.querySlotCond.L.Unlock()

        madeChanges := false

        for </span><span class="cov0" title="0">{
                lastElem := server.freeQuerySlots.Back()
                if lastElem == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">info := lastElem.Value.(*querySlotInfo)

                if time.Since(info.lastUse) &gt; g.MaxIdleTime </span><span class="cov0" title="0">{
                        server.freeQuerySlots.Remove(lastElem)
                        server.inFlightQueries--
                        openConnections.WithLabelValues(server.Addr).Set(float64(server.inFlightQueries))
                        go info.close()
                        madeChanges = true
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">if madeChanges </span><span class="cov0" title="0">{
                server.querySlotCond.Signal()
        }</span>
}

func (g *Generator) cleanupAllQuerySlots() <span class="cov0" title="0">{
        for _, server := range g.Servers </span><span class="cov0" title="0">{
                g.cleanupServerQuerySlots(server)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package static

import (
        "crypto"
        "io"
        "log"
        "os"
        "sync"

        "github.com/Doridian/foxDNS/handler"
        "github.com/Doridian/foxDNS/util"
        "github.com/fsnotify/fsnotify"
        "github.com/miekg/dns"
)

type zoneConfig struct {
        file           string
        origin         string
        defaultTTL     uint32
        includeAllowed bool
}

type Generator struct {
        configs        []zoneConfig
        records        map[string]map[uint16][]dns.RR
        subResolvers   map[string]handler.Generator
        recordsLock    sync.RWMutex
        watcher        *fsnotify.Watcher
        enableFSNotify bool

        mux dns.Handler

        zone                 string
        enableSignatureCache bool
        signatureLock        sync.Mutex
        signatures           map[string]*dns.RRSIG
        zskDNSKEY            *dns.DNSKEY
        zskPrivateKey        crypto.PrivateKey
        kskDNSKEY            *dns.DNSKEY
        kskPrivateKey        crypto.PrivateKey
}

func New(enableFSNotify bool, mux dns.Handler, dnssec *DNSSECConfig) *Generator <span class="cov8" title="1">{
        gen := &amp;Generator{
                configs:        make([]zoneConfig, 0),
                records:        make(map[string]map[uint16][]dns.RR),
                subResolvers:   make(map[string]handler.Generator),
                watcher:        nil,
                enableFSNotify: enableFSNotify,
                mux:            mux,
        }
        gen.loadDNSSEC(dnssec)
        return gen
}</span>

func (r *Generator) LoadZoneFile(file string, origin string, defaultTTL uint32, includeAllowed bool) error <span class="cov0" title="0">{
        r.recordsLock.Lock()
        defer r.recordsLock.Unlock()
        return r.loadZoneFile(file, origin, defaultTTL, includeAllowed)
}</span>

func (r *Generator) LoadZone(rd io.Reader, file string, origin string, defaultTTL uint32, includeAllowed bool) error <span class="cov0" title="0">{
        r.recordsLock.Lock()
        defer r.recordsLock.Unlock()
        return r.loadZone(rd, file, origin, defaultTTL, includeAllowed)
}</span>

func (r *Generator) loadZoneFile(file string, origin string, defaultTTL uint32, includeAllowed bool) error <span class="cov0" title="0">{
        fh, err := os.Open(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.configs = append(r.configs, zoneConfig{
                file:           file,
                origin:         origin,
                defaultTTL:     defaultTTL,
                includeAllowed: includeAllowed,
        })

        if r.watcher != nil </span><span class="cov0" title="0">{
                err = r.watcher.Add(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return r.loadZone(fh, file, origin, defaultTTL, includeAllowed)</span>
}

func (r *Generator) loadZone(rd io.Reader, file string, origin string, defaultTTL uint32, includeAllowed bool) (err error) <span class="cov0" title="0">{
        origin = dns.CanonicalName(origin)

        parser := dns.NewZoneParser(rd, origin, file)
        parser.SetDefaultTTL(defaultTTL)
        parser.SetIncludeAllowed(includeAllowed)

        for </span><span class="cov0" title="0">{
                rr, ok := parser.Next()
                if !ok || rr == nil </span><span class="cov0" title="0">{
                        err = parser.Err()
                        return
                }</span>
                <span class="cov0" title="0">r.addRecord(rr)</span>
        }
}

func (r *Generator) AddSubHandler(name string, handler handler.Generator) <span class="cov0" title="0">{
        r.recordsLock.Lock()
        defer r.recordsLock.Unlock()
        r.subResolvers[dns.CanonicalName(name)] = handler
}</span>

func (r *Generator) AddRecord(rr dns.RR) <span class="cov8" title="1">{
        r.recordsLock.Lock()
        defer r.recordsLock.Unlock()
        r.addRecord(rr)
}</span>

func (r *Generator) addRecord(rr dns.RR) <span class="cov8" title="1">{
        hdr := rr.Header()
        if hdr.Class != dns.ClassINET </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">hdr.Name = dns.CanonicalName(hdr.Name)

        nameRecs := r.records[hdr.Name]
        if nameRecs == nil </span><span class="cov8" title="1">{
                nameRecs = make(map[uint16][]dns.RR)
                r.records[hdr.Name] = nameRecs
        }</span>

        <span class="cov8" title="1">typeRecs := nameRecs[hdr.Rrtype]
        if typeRecs == nil </span><span class="cov8" title="1">{
                typeRecs = []dns.RR{}
        }</span>
        <span class="cov8" title="1">nameRecs[hdr.Rrtype] = append([]dns.RR{rr}, typeRecs...)</span>
}

func (r *Generator) findAuthorityRecords(q *dns.Question, rcodeNameError int) ([]dns.RR, []dns.RR, []dns.EDNS0, int, string) <span class="cov8" title="1">{
        for off, end := 0, false; !end; off, end = dns.NextLabel(q.Name, off) </span><span class="cov8" title="1">{
                name := q.Name[off:]

                nameRecs := r.records[name]
                if nameRecs == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">typedRecs := nameRecs[dns.TypeSOA]
                if len(typedRecs) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, typedRecs, nil, rcodeNameError, ""
                }</span>

                <span class="cov8" title="1">typedRecs = nameRecs[dns.TypeNS]
                if len(typedRecs) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, typedRecs, nil, dns.RcodeSuccess, ""
                }</span>
        }

        <span class="cov8" title="1">return nil, nil, nil, rcodeNameError, ""</span>
}

func (r *Generator) HandleQuestion(questions []dns.Question, recurse bool, dnssec bool, wr util.Addressable) ([]dns.RR, []dns.RR, []dns.EDNS0, int, string) <span class="cov8" title="1">{
        answer, ns, edns0, rcode, handlerName := r.handleQuestionLocal(questions, recurse, dnssec, wr)

        if recurse </span><span class="cov8" title="1">{
                answer = r.resolveIfCNAME(questions, rcode, answer, wr)
        }</span>

        <span class="cov8" title="1">if dnssec </span><span class="cov8" title="1">{
                signer, err := r.signResponse(&amp;questions[0], answer)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error signing record for %s: %v", answer[0].Header().Name, err)
                }</span> else<span class="cov8" title="1"> if signer != nil </span><span class="cov0" title="0">{
                        answer = append(answer, signer)
                }</span>
        }

        <span class="cov8" title="1">return answer, ns, edns0, rcode, handlerName</span>
}

func (r *Generator) handleQuestionLocal(questions []dns.Question, recurse bool, dnssec bool, wr util.Addressable) ([]dns.RR, []dns.RR, []dns.EDNS0, int, string) <span class="cov8" title="1">{
        q := &amp;questions[0]

        r.recordsLock.RLock()
        defer r.recordsLock.RUnlock()

        subResolver := r.subResolvers[q.Name]
        if subResolver != nil </span><span class="cov0" title="0">{
                answer, ns, edns0, rcode, _ := subResolver.HandleQuestion(questions, recurse, false, wr)
                return answer, ns, edns0, rcode, subResolver.GetName()
        }</span>

        <span class="cov8" title="1">nameRecs := r.records[q.Name]
        if len(nameRecs) == 0 </span><span class="cov8" title="1">{
                return r.findAuthorityRecords(q, dns.RcodeNameError)
        }</span>

        <span class="cov8" title="1">typedRecs := nameRecs[q.Qtype]
        if len(typedRecs) &gt; 0 </span><span class="cov8" title="1">{
                return typedRecs, nil, nil, dns.RcodeSuccess, ""
        }</span>

        <span class="cov8" title="1">if q.Qtype == dns.TypeCNAME </span><span class="cov0" title="0">{
                return r.findAuthorityRecords(q, dns.RcodeSuccess)
        }</span>

        <span class="cov8" title="1">typedRecs = nameRecs[dns.TypeCNAME]
        if len(typedRecs) == 0 </span><span class="cov8" title="1">{
                return r.findAuthorityRecords(q, dns.RcodeSuccess)
        }</span>

        <span class="cov8" title="1">cname := typedRecs[0].(*dns.CNAME)

        localResolvedRecs, _, _, _, _ := r.handleQuestionLocal([]dns.Question{
                {
                        Name:   cname.Target,
                        Qtype:  q.Qtype,
                        Qclass: q.Qclass,
                },
        }, recurse, dnssec, wr)

        if localResolvedRecs != nil </span><span class="cov8" title="1">{
                typedRecs = append(typedRecs, localResolvedRecs...)
        }</span>

        <span class="cov8" title="1">return typedRecs, nil, nil, dns.RcodeSuccess, ""</span>
}

func (r *Generator) clearCache() <span class="cov0" title="0">{
        r.signatureLock.Lock()
        r.signatures = make(map[string]*dns.RRSIG)
        r.signatureLock.Unlock()
}</span>

func (r *Generator) Refresh() error <span class="cov0" title="0">{
        defer r.clearCache()

        r.recordsLock.Lock()
        defer r.recordsLock.Unlock()

        r.records = make(map[string]map[uint16][]dns.RR)
        for _, cf := range r.configs </span><span class="cov0" title="0">{
                err := r.loadZoneFile(cf.file, cf.origin, cf.defaultTTL, cf.includeAllowed)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Generator) Start() error <span class="cov0" title="0">{
        defer r.clearCache()

        if !r.enableFSNotify </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var err error
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.watcher = watcher

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">if event.Has(fsnotify.Write) </span><span class="cov0" title="0">{
                                        log.Printf("Reloading static generator because of file %s", event.Name)
                                        err := r.Refresh()
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Error reloading zone: %v", err)
                                        }</span>
                                }
                        case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">log.Printf("fsnotify error: %v", err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">for _, cf := range r.configs </span><span class="cov0" title="0">{
                err = r.watcher.Add(cf.file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Generator) Stop() error <span class="cov0" title="0">{
        defer r.clearCache()

        err := r.watcher.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.watcher = nil
        return nil</span>
}

func (r *Generator) GetName() string <span class="cov0" title="0">{
        return "static"
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package static

import (
        "github.com/Doridian/foxDNS/handler"
        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

func (r *Generator) resolveIfCNAME(questions []dns.Question, rcode int, recs []dns.RR, wr util.Addressable) []dns.RR <span class="cov8" title="1">{
        if r.mux == nil </span><span class="cov8" title="1">{
                return recs
        }</span>

        <span class="cov0" title="0">qtype := questions[0].Qtype
        // There can only legally ever be 1 CNAME, so dont even bother checking is multiple records
        if rcode != dns.RcodeSuccess || qtype == dns.TypeCNAME || len(recs) != 1 </span><span class="cov0" title="0">{
                return recs
        }</span>

        <span class="cov0" title="0">cname, ok := recs[0].(*dns.CNAME)
        if !ok </span><span class="cov0" title="0">{
                return recs
        }</span>

        <span class="cov0" title="0">subQ := dns.Question{
                Name:   dns.CanonicalName(cname.Target),
                Qtype:  qtype,
                Qclass: dns.ClassINET,
        }

        for _, oldQ := range questions </span><span class="cov0" title="0">{
                if oldQ.Name == subQ.Name &amp;&amp; oldQ.Qtype == subQ.Qtype &amp;&amp; oldQ.Qclass == subQ.Qclass </span><span class="cov0" title="0">{
                        return recs // Already queried this one
                }</span>
        }

        <span class="cov0" title="0">resp := handler.NewRecursiveResponseWriter(wr)

        subQMsg := &amp;dns.Msg{
                MsgHdr: dns.MsgHdr{
                        Id:               dns.Id(),
                        RecursionDesired: true,
                },
                Question: make([]dns.Question, 1, len(questions)+1),
        }
        subQMsg.Question[0] = subQ
        subQMsg.Question = append(subQMsg.Question, questions...)

        r.mux.ServeDNS(resp, subQMsg)

        subReply := resp.GetMsg()

        if subReply != nil &amp;&amp; subReply.Rcode == dns.RcodeSuccess </span><span class="cov0" title="0">{
                return append(recs, subReply.Answer...)
        }</span>

        <span class="cov0" title="0">return recs</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package static

import (
        "crypto/ecdsa"
        "fmt"
        "time"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

func (r *Generator) signResponse(q *dns.Question, answer []dns.RR) (dns.RR, error) <span class="cov8" title="1">{
        dnskey := r.zskDNSKEY
        privkey := r.zskPrivateKey
        if q.Qtype == dns.TypeDNSKEY </span><span class="cov0" title="0">{
                dnskey = r.kskDNSKEY
                privkey = r.kskPrivateKey
        }</span>

        <span class="cov8" title="1">if dnskey == nil || privkey == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(answer) == 0 </span><span class="cov0" title="0">{
                // TODO: NSEC3, maybe, probably not
                return nil, nil
        }</span>

        <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%d:%d", q.Name, q.Qclass, q.Qtype)

        if r.enableSignatureCache </span><span class="cov0" title="0">{
                r.signatureLock.Lock()
                defer r.signatureLock.Unlock()
                oldSigner := r.signatures[cacheKey]
                if oldSigner != nil &amp;&amp; oldSigner.Expiration &gt; uint32(time.Now().Add(time.Second*60).Unix()) </span><span class="cov0" title="0">{
                        return oldSigner, nil
                }</span>
                <span class="cov0" title="0">delete(r.signatures, cacheKey)</span>
        }

        <span class="cov0" title="0">signer := &amp;dns.RRSIG{}
        ttl := answer[0].Header().Ttl
        util.FillHeader(signer, r.zone, dns.TypeRRSIG, ttl)
        signer.TypeCovered = answer[0].Header().Rrtype
        signer.Labels = uint8(dns.CountLabel(answer[0].Header().Name))
        signer.OrigTtl = ttl
        signer.Expiration = uint32(time.Now().Add(3600 * time.Second).Unix())
        signer.Inception = uint32(time.Now().Unix())
        signer.SignerName = r.zone

        signer.KeyTag = dnskey.KeyTag()
        signer.Algorithm = dnskey.Algorithm
        err := signer.Sign(privkey.(*ecdsa.PrivateKey), answer)
        if err == nil &amp;&amp; r.enableSignatureCache </span><span class="cov0" title="0">{
                r.signatures[cacheKey] = signer
        }</span>
        <span class="cov0" title="0">return signer, err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package static

import (
        "os"

        "github.com/miekg/dns"
)

type DNSSECConfig struct {
        Zone string `yaml:"zone"`

        PublicZSKFile   string `yaml:"public-zsk"`
        PrivateZSKFile  string `yaml:"private-zsk"`
        PublicKSKFile   string `yaml:"public-ksk"`
        PrivateKSKFile  string `yaml:"private-ksk"`
        CacheSignatures bool   `yaml:"cache-signatures"`
}

func (r *Generator) loadDNSSEC(config *DNSSECConfig) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">r.signatures = make(map[string]*dns.RRSIG)
        r.enableSignatureCache = config.CacheSignatures
        r.zone = config.Zone

        if config.PublicZSKFile != "" </span><span class="cov0" title="0">{
                // Load ZSK
                fh, err := os.Open(config.PublicZSKFile)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">pubkey, err := dns.ReadRR(fh, config.PublicZSKFile)
                _ = fh.Close()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">r.zskDNSKEY = pubkey.(*dns.DNSKEY)

                fh, err = os.Open(config.PrivateZSKFile)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">r.zskPrivateKey, err = r.zskDNSKEY.ReadPrivateKey(fh, config.PrivateZSKFile)
                _ = fh.Close()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                // Load KSK
                <span class="cov0" title="0">fh, err = os.Open(config.PublicKSKFile)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">pubkey, err = dns.ReadRR(fh, config.PublicKSKFile)
                _ = fh.Close()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">r.kskDNSKEY = pubkey.(*dns.DNSKEY)

                fh, err = os.Open(config.PrivateKSKFile)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">r.kskPrivateKey, err = r.kskDNSKEY.ReadPrivateKey(fh, config.PrivateKSKFile)
                _ = fh.Close()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handler

import (
        "net"

        "github.com/miekg/dns"
)

type TestResponseWriter struct {
        HadWrites       bool
        LastMsg         *dns.Msg
        LastHandlerName string

        LocalAddrVal  net.Addr
        RemoteAddrVal net.Addr
}

var _ = dns.ResponseWriter(&amp;TestResponseWriter{})

func (w *TestResponseWriter) WriteMsg(msg *dns.Msg) error <span class="cov0" title="0">{
        w.HadWrites = true
        w.LastMsg = msg
        return nil
}</span>

func (w *TestResponseWriter) Close() error <span class="cov0" title="0">{
        w.HadWrites = true
        return nil
}</span>

func (w *TestResponseWriter) Hijack() <span class="cov0" title="0">{
        w.HadWrites = true
}</span>

func (w *TestResponseWriter) Network() string <span class="cov0" title="0">{
        return "udp"
}</span>

func (w *TestResponseWriter) LocalAddr() net.Addr <span class="cov0" title="0">{
        if w.LocalAddrVal == nil </span><span class="cov0" title="0">{
                return &amp;net.TCPAddr{
                        IP:   net.IPv4(127, 0, 0, 1),
                        Port: 53,
                }
        }</span>
        <span class="cov0" title="0">return w.LocalAddrVal</span>
}

func (w *TestResponseWriter) RemoteAddr() net.Addr <span class="cov0" title="0">{
        if w.RemoteAddrVal == nil </span><span class="cov0" title="0">{
                return &amp;net.TCPAddr{
                        IP:   net.IPv4(127, 0, 0, 2),
                        Port: 5053,
                }
        }</span>
        <span class="cov0" title="0">return w.RemoteAddrVal</span>
}

func (w *TestResponseWriter) TsigStatus() error <span class="cov0" title="0">{
        return nil
}</span>

func (w *TestResponseWriter) TsigTimersOnly(timersOnly bool) <span class="cov0" title="0">{
        w.HadWrites = true
}</span>

func (w *TestResponseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        w.HadWrites = true
        return len(data), nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package server

import (
        "log"
        "sync"

        "github.com/Doridian/foxDNS/util"
        "github.com/miekg/dns"
)

type Server struct {
        listen []string

        handler     dns.Handler
        handlerLock sync.RWMutex

        serveWait      sync.WaitGroup
        initWait       sync.WaitGroup
        privDropWait   sync.WaitGroup
        enablePrivDrop bool

        serverLock sync.Mutex
        servers    map[*dns.Server]bool
}

func NewServer(listen []string, enablePrivDrop bool) *Server <span class="cov0" title="0">{
        return &amp;Server{
                listen:         listen,
                servers:        make(map[*dns.Server]bool),
                enablePrivDrop: enablePrivDrop,
        }
}</span>

func (s *Server) ServeDNS(wr dns.ResponseWriter, msg *dns.Msg) <span class="cov0" title="0">{
        s.handlerLock.RLock()
        handler := s.handler
        s.handlerLock.RUnlock()
        handler.ServeDNS(wr, msg)
}</span>

func (s *Server) SetHandler(handler dns.Handler) <span class="cov0" title="0">{
        s.handlerLock.Lock()
        defer s.handlerLock.Unlock()
        s.handler = handler
}</span>

func (s *Server) WaitReady() <span class="cov0" title="0">{
        s.initWait.Wait()
        s.privDropWait.Wait()
}</span>

func (s *Server) Serve() <span class="cov0" title="0">{
        s.privDropWait.Add(1)

        for _, listen := range s.listen </span><span class="cov0" title="0">{
                s.initWait.Add(1)
                s.serveWait.Add(1)
                go s.serve("tcp", listen)

                s.initWait.Add(1)
                s.serveWait.Add(1)
                go s.serve("udp", listen)
        }</span>

        <span class="cov0" title="0">s.initWait.Wait()
        if s.enablePrivDrop </span><span class="cov0" title="0">{
                dropPrivs()
        }</span>
        <span class="cov0" title="0">s.privDropWait.Done()

        log.Printf("Server fully initialized!")

        s.serveWait.Wait()</span>
}

const QRBit = 1 &lt;&lt; 15

func msgAcceptFunc(dh dns.Header) dns.MsgAcceptAction <span class="cov0" title="0">{
        if dh.Bits&amp;QRBit != 0 </span><span class="cov0" title="0">{ // is response
                return dns.MsgIgnore
        }</span>

        <span class="cov0" title="0">opcode := int(dh.Bits&gt;&gt;11) &amp; 0xF
        if opcode != dns.OpcodeQuery </span><span class="cov0" title="0">{
                return dns.MsgRejectNotImplemented
        }</span>

        <span class="cov0" title="0">if dh.Qdcount != 1 || dh.Ancount &gt; 0 || dh.Nscount &gt; 0 || dh.Arcount &gt; 2 </span><span class="cov0" title="0">{
                return dns.MsgReject
        }</span>

        <span class="cov0" title="0">return dns.MsgAccept</span>
}

func (s *Server) serve(net string, addr string) <span class="cov0" title="0">{
        defer s.serveWait.Done()
        initWaitSync := sync.Mutex{}
        initWaitSet := false

        initWaitDone := func() </span><span class="cov0" title="0">{
                initWaitSync.Lock()
                defer initWaitSync.Unlock()
                if initWaitSet </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">initWaitSet = true
                s.initWait.Done()</span>
        }
        <span class="cov0" title="0">defer initWaitDone()

        s.serverLock.Lock()
        dnsServer := &amp;dns.Server{
                Addr:          addr,
                Net:           net,
                Handler:       s,
                UDPSize:       int(util.UDPSize),
                ReadTimeout:   util.DefaultTimeout,
                WriteTimeout:  util.DefaultTimeout,
                MsgAcceptFunc: msgAcceptFunc,
                NotifyStartedFunc: func() </span><span class="cov0" title="0">{
                        log.Printf("Listening on %s net %s", addr, net)
                        initWaitDone()
                        s.privDropWait.Wait()
                        log.Printf("Handling requests on %s net %s", addr, net)
                }</span>,
        }
        <span class="cov0" title="0">s.servers[dnsServer] = true
        s.serverLock.Unlock()

        defer func() </span><span class="cov0" title="0">{
                s.serverLock.Lock()
                delete(s.servers, dnsServer)
                s.serverLock.Unlock()
        }</span>()

        <span class="cov0" title="0">err := dnsServer.ListenAndServe()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error listening on %s net %s: %v", addr, net, err)
        }</span>
}

func (s *Server) Shutdown() <span class="cov0" title="0">{
        s.serverLock.Lock()
        for dnsServer := range s.servers </span><span class="cov0" title="0">{
                _ = dnsServer.Shutdown()
        }</span>
        <span class="cov0" title="0">s.servers = make(map[*dns.Server]bool)
        s.serverLock.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//go:build darwin

package server

import (
        "log"
        "os"
        "strconv"
        "syscall"
)

func dropPrivs() <span class="cov0" title="0">{
        uid, _ := strconv.Atoi(os.Getenv("PUID"))
        gid, _ := strconv.Atoi(os.Getenv("PGID"))

        log.Printf("Startup IDs: UID = %d, GID = %d", syscall.Getuid(), syscall.Getgid())

        if gid &gt; 0 </span><span class="cov0" title="0">{
                err := syscall.Setregid(gid, gid)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error dropping GID: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if uid &gt; 0 </span><span class="cov0" title="0">{
                err := syscall.Setreuid(uid, uid)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error dropping UID: %v", err)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Runtime IDs: UID = %d, GID = %d", syscall.Getuid(), syscall.Getgid())</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package util

import (
        "crypto"
        "crypto/rand"
        "crypto/subtle"
        "time"
)

var previousCookieSecret []byte
var currentCookieSecret []byte
var clientCookiePrefix = []byte("client")
var serverCookiePrefix = []byte("server")

const cookieRotationTime = time.Minute * 30

// These are specified by DNS and not adjustable
const ClientCookieLength = 8
const MinServerCookieLength = 8

// This length can be adjusted between 8 and 32
const ServerCookieLength = 8

var cookieRotateTicket = time.NewTicker(cookieRotationTime)

func init() <span class="cov0" title="0">{
        rotateCookieSecret()

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        &lt;-cookieRotateTicket.C
                        rotateCookieSecret()
                }</span>
        }()
}

func rotateCookieSecret() <span class="cov0" title="0">{
        previousCookieSecret = currentCookieSecret
        currentCookieSecret = make([]byte, 64)
        _, err := rand.Read(currentCookieSecret)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func getCookieSecret(previous bool) []byte <span class="cov0" title="0">{
        if previous </span><span class="cov0" title="0">{
                return previousCookieSecret
        }</span>
        <span class="cov0" title="0">return currentCookieSecret</span>
}

func generateCookie(previous bool, len int, data ...[]byte) []byte <span class="cov0" title="0">{
        hash := crypto.SHA256.New()
        cookieSecret := getCookieSecret(previous)
        if cookieSecret == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">hash.Write(cookieSecret[0:32])
        for _, d := range data </span><span class="cov0" title="0">{
                hash.Write(d)
        }</span>
        <span class="cov0" title="0">return hash.Sum(cookieSecret[32:64])[:len]</span>
}

func GenerateClientCookie(previous bool, server string) []byte <span class="cov0" title="0">{
        return generateCookie(previous, ClientCookieLength, clientCookiePrefix, []byte(server))
}</span>

func GenerateServerCookie(previous bool, clientCookie []byte, wr Addressable) []byte <span class="cov0" title="0">{
        serverIp := ExtractIP(wr.LocalAddr())
        clientIp := ExtractIP(wr.RemoteAddr())
        return generateCookie(previous, ServerCookieLength, serverCookiePrefix, serverIp, clientIp, clientCookie)
}</span>

func CookieCompare(a []byte, b []byte) bool <span class="cov0" title="0">{
        if a == nil || b == nil || len(a) == 0 || len(b) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return subtle.ConstantTimeCompare(a, b) == 1</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package util

import (
        "github.com/miekg/dns"
)

const (
// EDNS0QDEPTH uint16 = iota + dns.EDNS0LOCALSTART
)

func GetEDNS0LocalOpt(msg *dns.Msg, code uint16) *dns.EDNS0_LOCAL <span class="cov0" title="0">{
        edns0 := msg.IsEdns0()
        if edns0 == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, opt := range edns0.Option </span><span class="cov0" title="0">{
                if opt.Option() == code </span><span class="cov0" title="0">{
                        edns0Local, ok := opt.(*dns.EDNS0_LOCAL)
                        if ok </span><span class="cov0" title="0">{
                                return edns0Local
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package util

import (
        "encoding/hex"

        "github.com/miekg/dns"
)

func SetEDNS0(msg *dns.Msg, option []dns.EDNS0, paddingLen int, dnssecOk bool) *dns.OPT <span class="cov0" title="0">{
        if option == nil </span><span class="cov0" title="0">{
                option = []dns.EDNS0{}
        }</span>

        <span class="cov0" title="0">edns0 := &amp;dns.OPT{
                Hdr: dns.RR_Header{
                        Name:   ".",
                        Rrtype: dns.TypeOPT,
                },
                Option: option,
        }
        edns0.SetUDPSize(UDPSize)
        edns0.SetDo(dnssecOk)

        msg.Extra = append(msg.Extra, edns0)

        if paddingLen &gt; 0 </span><span class="cov0" title="0">{
                edns0Padding := &amp;dns.EDNS0_PADDING{}
                edns0.Option = append(edns0.Option, edns0Padding)

                padMissing := msg.Len() % paddingLen
                if padMissing &gt; 0 </span><span class="cov0" title="0">{
                        edns0Padding.Padding = make([]byte, paddingLen-padMissing)
                }</span>
        }

        <span class="cov0" title="0">return edns0</span>
}

var secureProtocols = map[string]bool{
        "tcp":        true,
        "tcp-tls":    true,
        "tcp4":       true,
        "tcp6":       true,
        NetworkLocal: true,
}

func IsSecureProtocol(proto string) bool <span class="cov0" title="0">{
        return secureProtocols[proto]
}</span>

func ApplyEDNS0Reply(query *dns.Msg, reply *dns.Msg, option []dns.EDNS0, wr Addressable) *dns.OPT <span class="cov0" title="0">{
        queryEdns0 := query.IsEdns0()
        if queryEdns0 == nil </span><span class="cov0" title="0">{
                if reply.Rcode &gt; 0xF </span><span class="cov0" title="0">{
                        // Unset extended RCODE if client doesn't speak EDNS0
                        reply.Rcode = dns.RcodeServerFailure
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">paddingAllowed := RequireCookie || IsSecureProtocol(wr.Network())
        clientRequestedPadding := false

        for _, opt := range queryEdns0.Option </span><span class="cov0" title="0">{
                if opt.Option() != dns.EDNS0PADDING </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">clientRequestedPadding = true
                break</span>
        }

        <span class="cov0" title="0">paddingLen := 0
        if paddingAllowed &amp;&amp; clientRequestedPadding </span><span class="cov0" title="0">{
                paddingLen = 468
        }</span>
        <span class="cov0" title="0">return SetEDNS0(reply, option, paddingLen, queryEdns0.Do())</span>
}

func ApplyEDNS0ReplyEarly(query *dns.Msg, reply *dns.Msg, wr Addressable) (bool, []dns.EDNS0) <span class="cov0" title="0">{
        queryEdns0 := query.IsEdns0()

        doRequireCookie := RequireCookie
        if IsSecureProtocol(wr.Network()) </span><span class="cov0" title="0">{
                doRequireCookie = false
        }</span>

        <span class="cov0" title="0">if queryEdns0 == nil </span><span class="cov0" title="0">{
                if doRequireCookie </span><span class="cov0" title="0">{
                        reply.Rcode = dns.RcodeRefused
                        return false, nil
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        }

        <span class="cov0" title="0">if queryEdns0.Version() != 0 </span><span class="cov0" title="0">{
                reply.Rcode = dns.RcodeBadVers
                SetEDNS0(reply, nil, 0, false)
                return false, nil
        }</span>

        <span class="cov0" title="0">option := make([]dns.EDNS0, 0, 1)

        cookieMatch := false
        cookieFound := false

        for _, opt := range queryEdns0.Option </span><span class="cov0" title="0">{
                if opt.Option() != dns.EDNS0COOKIE </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">cookieOpt, ok := opt.(*dns.EDNS0_COOKIE)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">binaryCookie, err := hex.DecodeString(cookieOpt.Cookie)
                if err != nil || binaryCookie == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if len(binaryCookie) &lt; ClientCookieLength </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">clientCookie := binaryCookie[:ClientCookieLength]
                generatedServerCookie := GenerateServerCookie(false, clientCookie, wr)

                if len(binaryCookie) == ClientCookieLength+ServerCookieLength </span><span class="cov0" title="0">{
                        receivedServerCookie := binaryCookie[ClientCookieLength:]

                        cookieMatch = CookieCompare(receivedServerCookie, generatedServerCookie)
                        if !cookieMatch </span><span class="cov0" title="0">{ // If no match, try previous cookie
                                previousServerCookie := GenerateServerCookie(true, clientCookie, wr)
                                cookieMatch = CookieCompare(receivedServerCookie, previousServerCookie)
                        }</span>
                }

                <span class="cov0" title="0">cookieFound = true
                option = append(option, &amp;dns.EDNS0_COOKIE{
                        Code:   dns.EDNS0COOKIE,
                        Cookie: hex.EncodeToString(append(clientCookie, generatedServerCookie...)),
                })
                break</span>
        }

        <span class="cov0" title="0">if doRequireCookie &amp;&amp; !cookieMatch </span><span class="cov0" title="0">{
                if cookieFound </span><span class="cov0" title="0">{
                        reply.Rcode = dns.RcodeBadCookie
                }</span> else<span class="cov0" title="0"> {
                        reply.Rcode = dns.RcodeRefused
                }</span>
                <span class="cov0" title="0">SetEDNS0(reply, option, 0, queryEdns0.Do())
                return false, option</span>
        }

        <span class="cov0" title="0">return true, option</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package util

import (
        "net"

        "github.com/miekg/dns"
)

const NetworkLocal = "local"

type Addressable interface {
        LocalAddr() net.Addr
        RemoteAddr() net.Addr
        Network() string
}

func ExtractIP(addr net.Addr) net.IP <span class="cov0" title="0">{
        switch convAddr := addr.(type) </span>{
        case *net.TCPAddr:<span class="cov0" title="0">
                return convAddr.IP</span>
        case *net.UDPAddr:<span class="cov0" title="0">
                return convAddr.IP</span>
        case *net.IPAddr:<span class="cov0" title="0">
                return convAddr.IP</span>
        default:<span class="cov0" title="0">
                return net.IPv4(0, 0, 0, 0)</span>
        }
}

func IPIsPrivateOrLocal(ip net.IP) bool <span class="cov0" title="0">{
        return ip.IsLoopback() || ip.IsLinkLocalUnicast() || ip.IsPrivate()
}</span>

func FillHeader(rr dns.RR, name string, rtype uint16, ttl uint32) dns.RR <span class="cov0" title="0">{
        hdr := rr.Header()
        hdr.Ttl = ttl
        hdr.Class = dns.ClassINET
        hdr.Rrtype = rtype
        hdr.Name = name
        hdr.Rdlength = 0
        return rr
}</span>

func IsBadQuery(q *dns.Question) bool <span class="cov0" title="0">{
        return q.Qclass != dns.ClassINET || q.Qtype == dns.TypeIXFR || q.Qtype == dns.TypeAXFR || q.Qtype == dns.TypeMAILA || q.Qtype == dns.TypeMAILB || q.Qtype == dns.TypeANY
}</span>

func IsLocalQuery(wr Addressable) bool <span class="cov0" title="0">{
        return wr.Network() == NetworkLocal
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
